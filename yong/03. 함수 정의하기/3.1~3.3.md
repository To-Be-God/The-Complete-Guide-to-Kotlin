### 3장
## 3.1 함수
- fun 키워드: 함수임을 나타냄
- : (타입) -> 반환 타입을 명시

> 자바와 달리 코틀린에서는 unreachable code가 오류가 아니다!
>

코틀린의 메소드 파라미터는 무조건 불변이다. 따라서 함수 본문에서 파라미터 값을 변경하면 에러가 발생한다.
> fun increment(n: Int) : Int { <br>
> return n++ // Error <br>
> }

코틀린은 call-by-value 의미론을 사용한다. 그러나 함수 파라미터로 참조형 데이터가 전달되면 이 떄는 참조가 복사된다.

함수 인자의 타입은 생략 불가하다.
다만 때에 따라 가능한 경우가 있는데,
- 유닛 타입을 반환 하는 경우 -> 자바에서 void인 경우와 동일
- 식이 본문인 함수 -> 단일 식으로 구성될 수 있는 경우   
  - `fun circleArea(radius: Double) : Double = PI*radius*radius`
  
### 위치 기반 인자와 이름 붙은 인자
자바에서는 기본적으로 함수 인자는 적혀진 위치를 기준으로 대입된다. 그러나 코틀린에서는 이름 붙은 인자 방식을 지원한다.
`rectangleArea(width = w, height = h)`
이처럼 이름을 붙여 파라미터를 넘길 수도 있다.

또한 위치 기반 인자와 이름 붙인 인자를 동시에 사용할 수도 있다.   
단 이 때는 위치 기반 인자의 위치가 타입이 맞지 않으면 에러가 발생한다. 즉, 위치 기반 인자의 위치는 지켜줘야 한다.

### 오버로딩과 디폴트 값
호출할 함수를 결정할 때 컴파일러 규칙
1. 파라미터의 개수와 타입을 기준으로 호출할 수 있는 모든 함수를 찾는다.
2. 덜 구체적인 함수를 제외시킨다.
3. 후보가 하나로 압축되면 이 함수가 호출할 함수이다. 후보가 둘 이상이면 컴파일 오류가 발생한다.

코틀린에서는 파라미터에 디폴트 값을 줄 수 있다.  
fun readInt(radix: Int = 10) = readLine()!!.toInt(radix)

### varang
함수의 파라미터 개수를 정해놓고 싶지 않을 때 사용할 수 있다.
fun printSorted(varang items: Int){

}
-> printSorted(1, 4, 3, 2) 이런 식으로 사용

스프레드 연산자 *   
배열을 넣으면 원소들을 하나씩 넣어주는 형태 이 때 배열을 얕은 복사하기 때문에 참조 배열의 경우 그 값을 공유한다.

둘 이상을 varang 파라미터로 선언하는 것은 불가.   
콤마로 분리하여 여러 인자와 스프레드를 섞어서 전달하는 것은 가능

default 값을 넣는 것과 varang 파라미터를 넣는 것은 인자의 가장 마지막에 넣는 것이 좋다!

### 함수의 영역과 가시성
- public
  - 프로젝트 어디서든 사용 가능
- private
  - 함수가 정의된 파일 안에서만 접근 가능
- internal
  - 같은 모듈 내에서 접근 가능
  
## 3.2 패키지와 임포트
자바랑 비슷하다.
   
import 문으로 바로 함수를 포함시키는 것도 가능
>import foo.bar.util.readInt   
println(readInt())

코틀린에서는 임포트 과정에서 함수에 alias를 줄 수 있다.   
>import app.util.foo.readline as fooReadLine   
import applutil.bar.readline as bar ReadLine

다음과 같이 alias를 주어 사용할 수 있다(파이썬과 비슷한 듯)

## 3.3 조건문
기본적으로 자바와 비슷하다.
자바와 다른 점은 코틀린에서는 if문을 식으로 사용할 수 있다.
> fun max(a: Int, b: Int) = if (a > b) a else b

if와 else 부분이 블록으로 된 경우도 가능하다. 이 때 반환 값은 블록의 맨 끝에 있는 식의 값이 된다.   
또한 식으로 사용할 때는 if, else가 둘 다 존재해야만 한다.

### 범위, 진행, 연산
범위를 만들 때는 .. 을 사용한다.
> val chars = 'a'...'h'   
> val twoDigits = 10.99

in 연산자를 통해 해당 숫자가 범위 안에 포함되는지 여부를 알 수 있다. 반대는 !in이다. 물론 대소 비교와 배열 원소 포함 여부 비교 가능하다. 

- ..의 경우 연산자 우선순위가 덧셈과 중위 연산 사이에 속한다.   
- in, !in 연산은 중위 연산과 비교 연산 사이에 속한다.   
- until, downTo, step,은 이름 붙은 중위 연산(and, or)과 우선순위가 같다.

.. 연산자는 처음과 끝 값을 포함하는 범위이다.

진해을 만들 때는 step과 downTo 등을 사용한다.
> 1..10 step 3 //1, 4, 7, 10   
> 15 downTo 9 step 2 //15, 13, 11, 9

단 진행의 간격은 양수를 사용해야 한다.   

만약 끝 값이 진행에 속한 원소가 아니라면 자동으로 끝 값에서 가장 가까운 값까지만 진행에 속하게 된다.

### when문과 여럿 중에 하나 선택하기
> when {   
  (조건) -> 결과   
  (조건) -> 결과   
  else -> 결과   
}

위와 같은 형태로 작성되며 if문과 마찬가지로 식으로도 사용될 수 있다.

switch문과 비슷해보인다.   

그러나 자바의 switch 문의 경우 만족하는 조건을 실행하고 break가 없으면 그 밑의 조건들도 모두 실행하는데 이를 fall-through라고 한다.   

when은 조건을 만족하는 가지만 실행하고 fall-through를 하지 않는다.