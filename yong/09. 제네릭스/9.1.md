### 9장

## 9.1 타입 파라미터

### 9.1.1 제네릭 선언
제네릭 선언을 만들려면 하나 이상의 타입 파라미터를 추가해야 한다.

> 자바에서는 점 바로 뒤에 각괄호를 이용해 타입을 전달하지만, 코틀린에서는 함수 이름 바로 뒤에 타입을 전달한다.

제네릭 클래스나 인터페이스를 사용해 데이터의 타입을 지정할 때는 반드시 타입 인자를 명시해야 한다.  
자바는 타입 파라미터를 지정하지 않은 로타입을 사용할 수 있지만, 코틀린은 이를 허용하지 않는다.

```kotlin
open class DataHolder<T>(val data: T)

class StringDataHolder(data: String) : DataHolder<String>(data)

class TreeNode<T>(data: T) : DataHolder<T>(data){
  ...
}
```
컴파일러는 일반 생성자 호춝과 달리 생성자 위임 호출의 타입 인자를 추론해주지 못한다. 따라서 항상 위임 호출의 타입 인자를 명시해야 한다.

타입 파라미터를 상속하지 않는다. 따라서 같은 타입 파라미터 변수명을 사용해도 무방하다.

제네릭 클래스에 정의된 함수와 프로퍼티에 클래스의 타입 파라미터를 사용할 수 있다. 또한, 프로퍼티나 함수에 타입 파라미터를 추가하면 프로퍼티나 함수 자체를 제너릭으로 만들 수 있다.

```kotlin
fun <T> TreeNode<T>.addChildren(vararg data: T) {
  data.forEach { addChild(it)}
}
```

클래스 멤버 프로퍼티는 타입 파라미터를 가질 수 없고, 오직 확장 프로퍼티만 타입 파라미터를 가질 수 있다. 이유는 이처럼 여러 값을 제공하는 것이 근본적으로 불가능하기 때문이다.

객체 선언에 타입 파라미터를 추가하는 것도 불가능하다.

프로퍼티 참조는 타입 인자를 지원하지 않는다.

### 9.1.2 바운드와 제약
타입 파라미터의 타입을 어느정도 제한하고 싶을 때는 상위 바운드를 설정하면 된다.
```kotlin
fun <T : Number>TreeNode<T>.average(): Double {
  ...
}
```

이렇게 사용하면 T가 Number의 하위 클래스인지 확인한다. 

타입 파라미터 바운드로 타입 파라미터를 사용할 수도 있는데, 이를 재귀적 타입 파라미터라고 한다.

바운드가 자신보다 앞에 있는 타입 파라미터를 가리킬 수도 있다.

타입 파라미터 구문을 사용하면 상위 바운드를 하나만 지정할 수 있다. 그러나 다음과 같이 where절을 클래스 선언 본문 앞에 추가하고 바운드할 타입 목록을 여러개 표시할 수도 있다.
```kotlin
class Registry<T> wgere T : Named, T : Identified{
  ...
}
```

### 9.1.3 타입 소거와 구체화
```kotlin
list is List<*>
map is Map<*, *>
```
다음과 같이 * 은 기본적으로 알지 못하는 타입을 뜻한다.

구체화는 타입 파라미터 정보를 런타임까지 유지한다는 뜻이다. 이는 인라인한 함수에 대해서만 구체화한 타입 파라미터를 쓸 수 있다는 데 있다.  
 호출 위치로 함수 본문을 인라인시키기 때문에 컴파일러가 인라인된 함수에 제공되는 타입 인자의 실제 타입을 항상 알 수 있다.

 구체화된 타입 파라미터를 사용하는 것은 빠르고 안전하지만, 인라인 함수를 타면 컴파일 됐을 때 코드 크기가 커질 수 있다.  
 
 또한 인라인 함수 안에서만 구체화한 타입 파라미터를 쓸 수 있기 때문에 구체화한 타입을 클래스나 프로퍼티와 함께 쓸 수는 없다.

 마지막으로 구체화한 타입 파라미터를 구체화하지 않은 타입 파라미터로 대신할 수는 없다.