### 12장

## 12.2 코틀린 코드를 자바에서 사용하기

#### 프로퍼티 접근
자바나 jvm에는 프로퍼티 개념이 없다. 따라서 접근자 시그니처는 다음 규칙에 따라 프로퍼티 정의에서 만들어진다.
- 게터는 파라미터가 없는 메서드이며 게터의 반환 타입은 원래의 프로퍼티 타입과 같다. 게터의 이름은 프로퍼티 이름의 첫 번째 글자를 대문자로 바꾼 다음, 앞에 get을 붙여서 생성된다.
- 세터는 새로운 값에 해당하는 파라미터를 하나만 받는 메서드다. 세터의 이름은 프로퍼티 이름의 첫 번째 글자를 대문자로 바꾼 다음, 앞에 set을 붙여서 생성된다.

코틀린 프로퍼티에 뒷받침 필드가 필요한 경우, 컴파일러가 접근자 메서드와 함께 필드도 만들어준다. 그러나 이는 비공개이기 때문에 밖에서 접근이 필요할 시 프로퍼티 앞에 `@JvmField` 애너테이션을 붙이면 된다.

이 경우 접근자 메서드는 생성되지 않고, 뒷받침 필드가 프로퍼티 자체와 동일한 가시성으로 만들어진다.

@JvmField를 추상 프로퍼티나 열린 프로퍼티에 적용할 수 없다. 이 프로퍼티를 오버라이드하는 쪽에서 커스텀 접근자를 만들 수 있기 때문이다.

이름 붙은 객체의 프로퍼티에 대해 @JvmField를 적용하면 인스턴스 필드가 아니라 정적 필드를 만들어낸다.

뒷받침 하는 필드를 노출하는 또 다른 방법으로 lateinit 프로퍼티를 활용하는 방법도 있다.

lateinit 프로퍼티에 @JvmField를 붙일 수 없다.

#### 파일 퍼사드와 최상위 선언
코틀린 컴파일러는 최상위 함수와 프로퍼티를 자동으로 파일 퍼사드라는 클래스에 넣는다. 기본적으로 퍼사드 클래스 이름은 이름 뒤에 Kt를 덧붙인 이름이 된다.

파일 수준의 @JvmName 애너테이션을 통해 퍼사드 클래스 이름을 지정할 수 있다.

```kotlin
@file:JvmName("MyUtils")
class Person(val firstName: String, val familyName: String)

val Person.fullName
  get() = "$firstName $familyName"

public class Main{
  public static void main(){
    System.out.println(MyUtils.getFullName(...))
  }
}
```

여러 파일에 있는 최상위 선언을 한 클래스로 모을 수도 있다. 합치려는 파일마다 @JvmMultifileCLass라는 애너테이션을 붙이고 JvmName으로 클래스 이름을 지정하면 된다.

퍼사드 클래스는 JVM에서만 접근 가능하다.

#### 객체와 정적 멤버
코틀린 객체는 자바 코드에서는 {클래스 이름}.INSTANCE 필드를 통해 객체 필드에 접근 가능하다.

객체 함수나 프로퍼티 접근자를 정적 메서드로 만들려면 @JvmStatic 애너테이션을 이용하면 된다.

#### 노출된 선언 이름 변경하기
@JvmName 애너테이션은 파일만 아니라 함수나 프로퍼티 접근자에도 적용할 수 있다.

```kotlin
@JvmName("getFullNameFamilyFirst")
fun getFullName(person: Person): String {
  return "${person.familyName}, ${person.firstName}"
}

@get:JvmName("getFullNameFamilyFirst")
val Person.fullName
  get() = "..."
```

다음과 같이 사용할 수 있다.

#### 오버로딩한 메서드 생성하기

코틀린 함수에 디폴트 값이 지정된 경우, 함수 인자 중 일부를 생략할 수 있기 때문에 함수를 호출할 때 인자의 수가 달라질 수 있다.

이에 대한 해결법으로 @JvmOverloads 애너테이션을 제공한다.

이 애너테이션을 적용하면 원래 코틀린 코드 외에 오버로딩된 함수를 추가로 생성한다.

- 마지막 파라미터를 제외한 나머지 인자를 받는 함수이며, 원래 코틀린 함수의 마지막 파라미터를 디폴트 값으로 지정해준다.
- 마지막 두 파라미터를 제외한 나머지 인자를 받는 함수, 마지막 두 파라미터를 디폴트 값으로 지정해준다.
- 이런 식으로 하나씩 디폴트 값으로 바꿔주는 인자를 하나씩 늘려가며 오버로딩한 함수들을 만들어낸다.

결과적으로 정리하면, 그냥 모든 경우에 대해서 다 오버로딩한다는 뜻이다.

#### 예외 선언하기
코틀린에서는 검사 예외 비검사 예외를 구분하지 않기 때문에 이를 구분하는 자바와 충돌이 날 수도 있다. 따라서 필요한 경우 @Throws(예외 클래스)애너테이션을 통해 예외 클래스를 지정할 수 있다.

#### 인라인 함수
현재 인라인을 사용하지 않고 타입 구체화를 표현할 방법이 없으므로, 자바코드에서 이런 함수를 호출하는 것은 불가능하다.

#### 타입 별명
자바에서 볼 때 타입 별명을 참조하는 선언은 모두 원래 타입을 가리키는 것으로 보인다.



