### 4장

## 4.1 클래스 정의하기
코틀린 1.3부터는 인라인 클래스가 도입 되었다. 이를 이용하면 참조 타입이 아닌 타입을 정의할 수 있다.

### 클래스 내부 구조
선언하는 방식은 자바와 동일하다.   
프로퍼티와 멤버 함수 등을 선언하는 것도 동일하다.(this 사용도 동일)   
코틀린에서는 객체를 생성할 때 new 연산자를 사용하지 않는다.

기본적으로 코틀린 클래스는 public이다.   
최상위 함수와 마찬가지로 최상위 클래스 또한 접근 제어자를 private, internal로 바꿀 수 있다.

클래스 밖에 작성된 함수와 변수 등을 컴파일러가 변환하는 과정
https://heechokim.tistory.com/7   
ㄴ 요약하면, 최상위 함수, 프로퍼티가 포함된 코틀린 파일을 컴파일 할 때 해당 파일 이름 뒤에 Kt를 붙인 클래스를 새로 생성하여 해당 파일에 정적으로 함수와 변수를 할당한다.

코틀린에서는 소스 파일의 이름을 그 안에 들어있는 공개 클래스 이름과 동일하게 만들 필요가 없다!(자바는 강제)   

한 파일 안에 여러 공개 클래스를 넣을 수도 있다. -> 그래도 클래스 하나만 있으면 보통 파일 이름을 맞춘다고 한다.

 ### 생성자
 #### 주 생성자
 코틀린에서는 클래스 이름 옆에 괄호로 생성자를 만들 수 있다.
 ```kotlin
 class Person(firstName: String, familyName: String) {
  val fullName = "$firstName $familyName"
 }
 ```
이를 **주 생성자(Primary Constructor)** 라고 한다.   
이 때 사실 괄호 사이에 constructor 키워드가 생략되어 있다.
이는 생성자에 어노테이션이나, 가시성 변경자가 없는 경우 생략 가능하다.

또한 val, var 키워드를 붙이면 해당 프로퍼티를 선언, 초기화 둘 다 해준다. 그러나 붙이지 않으면 단순히 생성자 파라미터로 인식되기 때문에 따로 멤버 프로퍼티를 만들어 초기화 해주어야 한다. -> `val tempName = firstName` 요렇게도 가능

주 생성자 안에는 디폴트 값도 넣어줄 수 있고, vararg도 사용 가능하다.

---
#### 초기화 블럭
```kotlin
class Person(firstName: String, familyName: String) {
  val fullName = "$firstName $familyName"

  init{
    println("Created new Person instance: $fullName)
  }
 }
```
코틀린에서도 초기화 블럭을 지원한다. init문 안에서 프로퍼티 초기화가 가능하며 return문이 올 수 없다. 

또한 init문은 여러 개 작성 가능하다. (이 때는 순서대로 실행 됨)    
실행 순서는 주 생성자 -> 초기화 블럭 -> 부 생성자 이다.
https://m.blog.naver.com/yuyyulee/221213018263

#### 부 생성자
- 자바의 생성자를 정의하는 것과 비슷하다.   
- 문법은 `construct(인자1, 인자2...)`와 같이 사용한다.
- 부 생성자에는 return 가능 (Unit 타입 반환)
- val, var 키워드 사용 불가

실제로는 주 생성자와 디폴트 값으로 대부분 생성자를 해결한다고 한다!

### 멤버 가시성
코틀린에서 지원하는 멤버 가시성 키워드는 다음과 같다.
- public
  - 디폴트 가시성, 어디서나 접근 가능
- internal
  - 멤버가 속한 클래스가 포함된 컴파일 모듈 내부에서만 접근 가능
- protected
  - 멤버가 속한 클래스와 멤버가 속한 클래스의 모든 하위 클래스 안에서 접근 가능
- private
  - 멤버가 속한 클래스 내부에서만 접근 가능
  
가시성 변경자는 **함수, 프로퍼티, 주 생성자, 부 생성자**에 대해 지원된다. 주셍성자의 가시성을 지정하려면 constructor 키워드를 반드시 명시해야 한다.

### 내포된 클래스
클래스 안에 클래스를 가질 수 있다. (nested class)   
내포된 클래스 또한 가시성 변경자를 붙일 수 있으며, 접근 시 바깥의 클래스부터 차례대로 접근해야 한다.   

- 바깥쪽 클래스는 내포된 클래스의 비공개 멤버에 접근할 수 없다.
- 내포된 클래스에 inner를 붙이면 자신을 둘러싼 외부 클래스의 현재 인스턴스에 접근할 수 있다.
- this는 기본적으로 가장 내부의 클래스를 지칭한다. 바깥의 클래스를 지칭하고 싶으면 `this@{외부 클래스 이름}` 을 사용하면 된다.
- 코틀린 에서는 inner 키워드가 붙은 클래스만 바깥 클래스와 연관이 있다.   
  -> 이로 인해 inner가 붙은 클래스에서는 바깥 클래스의 프로퍼티에 접근할 수 있는 것이다.


### 지역 클래스
코틀린에서도 함수 본문에 클래스를 정의할 수 있다. 이 클래스는 함수 안에서만 사용 가능하다.

코틀린은 지역 클래스에서 클래스 바깥에 있는 변수의 값을 포획하여 변경할 수도 있다.
```kotlin
fun main(){
  var x = 1

  class Counter{
    fun increment(){
      x++
    }
  }

  Counter().increment()

  println(x)
}
```

그러나 이러한 코드는 컴파일러가 실행하는 과정에서 변수를 wrapping하기 때문에 비용이 발생한다. 불변 변수의 경우 비용이 발생하지 않는다. (알아만 두자!)

지역 클래스에는 가시성 변경자를 붙일 수 없다.

지역 클래스도 함수, 프로퍼티, 생성자, 내포된 클래스 등 모두 포함 가능하다. 그러나 내포된 클래스의 경우 반드시 inner 클래스이어야 한다.

## 4.2 널 가능성
코틀린을 쓰는 이유 중 하나

### 널이 될 수 있는 타입
코틀린에서 모든 참조 타입은 널이 될 수 없는 타입이다.

- 널이 될 수도 있는 타입을 선언하려면 타입 뒤에 ? 를 붙여야 한다.
`ex) val s: String? = "abc"`

- 널이 될 수 있는 타입은 널이 될 수 없는 타입의 상위 타입이다.   
`String? > String`

- 컴파일러는 널이 될 수 있는 타입은 항상 박싱한 값만 표현한다.
`val x: Int? = 1 // 박싱한 타입의 값을 참조`

- 가장 작은 널이 될 수 있는 타입 -> Nothing?   
널 말고는 아무것도 아님

- 가장 큰 널이 될 수 있는 타입 -> Any?   
모든 타입의 조상 Any가 널이 될 수 있다는 뜻

- ?이 붙은 변수는 어떠한 메소드와 프로퍼티도 제공하지 않는다. (예외 있음 )

### 널 가능성과 스마트 캐스트

#### 스마트 캐스트
```kotlin
fun isLetterString(s: String?): Boolean{
  if (s == null) return false

  //s는 여기서 널이 될 수 없다.
  if (s.isEmpty()) return false

  for (ch in s){
    if(!ch.isLetter()) return false
  }

  return true
}
```
코틀린은 함수 흐름을 파악하여 반드시 널이 아닌 경우에는 ? 가 붙은 변수를 널이 될 수 없는 타입으로 바꾸어 준다. 이를 **스마트 캐스트** 라고 한다.

이러한 스마트 캐스트는 when이나 루프 등에도 적용된다.   
그러나 변수에 값을 입력 받거나 가변 프로퍼티의 경우 스마트 캐스트가 작동하지 않는다.(값이 변할 수 있기 때문)

### 널 아님 단언 연산자
!! -> 널 아님 단언 연산자라고 부른다.

말 그대로 널이 아니야!! 라고 단언해주는 연산자이다. 그러나 이러한 방식은 널의 가능성을 다시 만들어낼 수 있기 때문에 사용하지 않는 것이 좋다.

연산자 우선순위는 가장 높다고 한다.

### 안전한 호출 연산자
?. -> 안전한 호출 연산자라고 부른다.   
`fun readInt() = readLine()?.toInt()`   
다음 코드의 의미는 readLine() 값이 널이면 널을 반환하고 널이 아니면 toInt() 함수를 실행하라 라는 의미이다.

즉 ?. 연산자를 사용하면 **수신 객체가 널이 아닌 경우에는 의미 있는 일을 하고, 수신 객체가 널인 경우에는 널을 반환하라** 라는 의미로 사용할 수 있다.

`println(readLine()?.toInt()?.toString(16))`   
이런 식으로 연쇄적으로 사용할 수도 있다.

### 엘비스 연산자
?: -> 엘비스 연산자라고 부른다.   
널에 대한 삼항 연산자 느낌인 것 같다.

`val n = readLine()?.toInt() ?: 0`   
다음 코드의 의미는 readLine() 값이 널일 경우 0을 반환하라 라는 의미이다.

즉 ?: 기준 왼쪽 식의 실행 결과가 널이 아닐 경우 그대로 반환, 널일 경우 오른쪽 값을 반환하는 형태이다.

return이나 throw와 함께 사용하는 것도 좋다.

우선순위는 엘비스 연산자의 경우 중위 연산자와 in, !in 사이에 위치한다. 비교, 동등성 연산자나 ||, && 대입보다 우선순위가 높다.
