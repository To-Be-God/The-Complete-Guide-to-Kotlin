### 8장

## 8.2 추상 클래스와 인터페이스
코틀린도 자바처럼 추상 클래스를 지원한다. class 앞에 abstract 키워드를 통해 추상클래스를 만들 수 있다.

### 추상 클래스와 추상 멤버
추상 클래스도 생성자가 존재할 수 있지만, 비추상 클래스와의 차이점은 추상 클래스 생성자의 경우 오직 하위 클래스의 생성자에서 위임 호출로만 호출될 수 있다는 점이다.

추상클래스 또한 추상 멤버를 정의할 수 있다.

추상 멤버 정의 시 제약 사항
- 추상 프로퍼티를 초기화할 수 없고 명시적인 접근자나 by절을 추가할 수 없다.
- 추상 함수에는 본문이 없어야 한다.
- 추상 프로퍼티와 함수 모두 명시적으로 반환 타입을 적어야 한다. 본문이나 초기화 코드가 없으므로 타입을 추론할 수 없기 때문이다.

추상 멤버는 암시적으로 열려 있다. 따라서 open 키워드를 따로 지정할 필요가 없다.

### 인터페이스
자바와 비스무리하다.

인터페이스 멤버는 디폴트가 추상 멤버이다. (기본적으로 abstract 키워드가 붙음)

인터페이스는 클래스나 다른 인터페이스의 상위 타입이 될 수 있다. 상속한 인터페이스를 하위 클래스에서 구현할 때도 동일하게 override를 붙여야 한다.

```kotlin
interface FlyingVehicle : Vehicle {
  val currentHeight: Int
  fun takeOff()
  fun land()
}

class Car : Vehicle {
  ...
}

class Aircraft : FlyingVehicle {
  ...
}
```

위 코드처럼 인터페이스를 상속할 때는 상위 타입 뒤에 괄호를 붙이지 않는다. 인터페이스는 생성자가 없기 때문이다.

```kotlin
interface Vehicle {
  val currentSpeed: Int
  fun move()
  fun stop()
  fun report() {
    println(if (isMoving) "Moving at $currentSpeed" else "Still")
  }
}
```

다음과 같이 함수와 프로퍼티에 구현을 추가할 수도 있다. 이러한 구현은 암시적으로 열려있는 것으로 간주된다.

인터페이스 멤버는 final로 선언 불가하다.  
그러나 확장 함수나 프로퍼티를 사용하면 final 멤버를 대신할 수 있다.  

인터페이스를 인터페이스로 상속할 때도 메서드 오버라이딩이 가능하다.

인터페이스 내부에 상태를 정의할 수 없으므로 인터페이스 안에는 뒷받침하는 필드가 들어있는 필드를 정의할 수 없다. 즉, 초기화 코드나 위임이 붙은 프로퍼티는 금지된다.

```kotlin
interface Vehicle {
  val currentSpeed = 0 //Error
  val maxSpeed by Lazy { 100} //Error
}
```

인터페이스 다중상속을 지원한다.

이 때 한 타입이 동일한 시그니처를 가지는 멤버가 들어있는 인터페이스를 둘 이상 상속받을 수도 있다.

```kotlin
interface Car {
  fun move()
}

interface Ship {
  fun move()
}

class Amphibia : Car, Ship {
  override fun move() {
    println("I'm moving")
  }
}
```

이러한 경우 혹여나 인터페이스 중 하나에 메소드가 구현되어있더라도 반드시 오버라이딩 하여 하위 클래스에서 해당 함수를 정의해야 한다.

만약 두 인터페이스 모두 구현되어있다면, `super<Car>.move()`와 같이 지정하여 사용해야 한다.

코틀린 설계는 인터페이스에서 상태를 허용하지 않음으로써 한 프로퍼티의 여러 상태가 존재할 수 있는 문제를 방지한다.

### 8.2.3 봉인된 클래스와 인터페이스
클래스, 인터페이스에 sealed 키워드를 지정하여 봉인된 클래스, 인터페이스를 만들 수 있다. 이러한 클래스를 상속하는 클래스는 내포된 클래스 또는 객체로 정의되거나 같은 파일 안에서 최상위 클래스로 정의돼야만 한다.

코틀린 1.5부터는 같은 컴파일 단위 안의 같은 패키지에 있는 봉인된 클래스나 인터페이스를 상속할 수 있게 됐다. 이런 영역 밖에서 봉인된 클래스는 final 클래스와 동일한 효과를 지니며, 아무도 봉인된 클래스를 상속할 수 없다.

봉인된 클래스의 생성자는 디폴트로 private이고, 가시성을 다른 값으로 변경하면 컴파일 시점에 오류로 간주된다.  
 봉인된 클래스도 빠진 부분이 없는 when 절을 지원한다.

 상속 제한은 봉인된 클래스를 직접 상속한 클래스에 대해서만 적용된다.

 코틀린 1.1부터는 봉인된 클래스가 다른 클래스를 상속할 수도 있다. 이로 인해 하위 클래스가 봉인된 클래스가 될 수도 있다.

 ### 8.2.4 위임
 ```kotlin
 class Alias(
  private val realIdentity: PersonData,
  private val newIdentity: PersonData
) : PersonData by newIdentity
 ```

 다음과 같이 상위 인터페이스 뒤에 by 키워드를 붙이고 위임할 인스턴스를 쓰면 된다.

 이제 Alias가 PersonData 인터페이스에서 상속한 모든 멤버는 newIdentity 인스턴스에 있는 이름과 시그니처가 같은 메서드를 통해 구현된다. 구현을 바꾸고 싶다면 직접 멤버를 오버라이드할 수 있다.

 클래스는 인터페이스 멤버를 구현할 때만 위임을 쓸 수 있다.
 