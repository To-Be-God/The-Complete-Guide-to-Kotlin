### 5장

## 5.1 코틀린을 활용한 함수형 프로그래밍

### 고차 함수
코틀린에는 함수의 인자로 함수를 넘길 수도 있다.

### 함수 타입
함수 타입은 다음 두 가지 부분으로 구성된다.
- 괄호로 둘러싸인 파라미터 타입 목록은 함숫값에 전달ㅚㄹ 데이터의 종류와 수를 정의한다.
- 반환 타입은  함수입의 함숫값을 호출면 돌려받게 되는 값의 타입을 명시한다.

ex_ (Int, Int) -> Boolean 이것이 함수 타입이다.

함수 타입인 값도 `op(result, numbers[i])`와 같이 일반 함수처럼 호출할 수 있다. 함숫값을 호출하는 다른 방법은 invoke() 메소드를 사용하는 것이다.
`result = op.invoke(result, numbers[i])`

함수 타입은 인자 뿐만 아니라 변수 등 타입이 쓰일 수 있는 모든 곳에 할당 가능하다. 또한 ?를 붙여 널이 될수 있는 타입으로 지정할 수도 있다.

만약 Int를 받아서 Int를 내놓는 함수를 인자로 받아서 Int를 결과로 내놓는 함수를 표현하고 싶으면

```kotlin
fun main(){
  val evalAtZero: ((Int) -> (Int)) -> Int = {f -> f(0)}
}
```
다음과 같이 사용할 수 있다.

### 람다와 익명 함수
`{result, op -> result + op}`라는 식을 람다식이라고 부른다. 

함수 정의와 달리 반환 타입을 지정할 필요가 없다.   
람다 본문의 맨 마지막에 있는 식이 람다의 결과값이 된다.   
람다의 파라미터 목록은 괄호로 감싸지 않는다. -> 괄호로 감쌀 시 구조 분해 선언이 된다.

람다가 함수의 마지막 프로퍼티인 경우, 함수를 호출할 때 인자를 둘러싸는 괄호 밖에 이 람다를 위치시킬 수 있다.
```kotlin
fun sum(numbers: IntArray) = 
aggregate(numbers) {result, op -> result + op}
```
배열 생성자와 지연 계산 프로퍼티에서 이러한 방식을 사용한다.

람다에 인자가 없으면 -> 를 생략할 수 있다.
`val time = measureTime{1 + 2}`

코틀린은 인자가 하나밖에 없는 람다의 경우 그 인자를 it라는 이름을 사용해 가리킬 수 있도록 기능을 제공한다.

람다의 파라미터 목록에서 사용하지 않는 람다 파라미터를 '_' 로 지정할 수 있다.

함숫값을 만드는 다른 방법은 익명 함수를 사용하는 것이다.
```kotlin
fun sum(numbers: IntArray) = aggregate(numbers, fun(result, op) = result + op)
```
익명 함수 문법 특징
- 이름을 지정하지 않는다. fun 키워드 다음에 바로 파라미터 목록이 온다.
- 람다와 마찬가지로 문맥에서 파라미터 타입을 추론할 수 있으면 파라미터 타입을 지정하지 않아도 된다.
- 함수 정의와 달리 익명 함수는 식이기 때문에 인자로 함수를 넘기거나 변수에 대입하는 등 일반 값처럼 쓸 수 있다.

익명 함수에서는 람다와 달리 반환 타입을 적을 수 있지만 람다는 인자 목록 밖에서 작성하는 것이 가능하지만 익명 함수는 불가능하다.

```kotlin
fun sum(numbers: IntArray) = aggregate(numbers, fun(result, op): Int {return result + op})
```

람다나 익명함수도 자신의 바깥 영역의 변수 값에 접근할 수 있다.

### 호출 가능 참조
이미 존재하는 함수 정의를 함수 타입의 식으로 사용하게 하는 간단한 방법

```kotlin
fun main(){
  println(check("Hello", ::isCapitalLetter))
}
```

::를 사용하여 호출 가능 참조를 만들 수 있으며, 최상위 프로퍼티, 함수를 호출하려면 `::inc` 이런 식으로 사용하면 된다.

:: 뒤에 클래스 이름이 오면 해당 클래스의 생성자에 대한 호출 가능 참조를 얻는다.

코틀린 1.1부터 바인딩된 호출 가능 참조 기능도 지원하는데,
객체 생성 이후 바로 ::(멤버 함수 이름)을 이용해 객체.함수 형식이 아닌 바로 함수 호출이 가능하다.

호출 가능 참조 자체는 오버로딩된 함수를 구분할 수 없다.
이 때는 반드시 함수 타입을 지정해주어야 한다.

코틀린 프로퍼티에 대한 호출 가능 참조를 만들 수도 있다. 이 참조는 실제 함숫값이 아닌 리플렉션 객체이다. 객체의 게터, 세터 프로퍼티를 사용하여 함숫값에 접근, 수정할 수 있다.
```kotlin
fun main() {
  val person = Person("John", "Doe")
  val readName = person::firstName.getter //게터 참조
  val writerFamily = person::familyName.setter //세터 참조
}
```

> ❗️ **자바의 메소드 참조와 호출 참조의 차이점**
> - 자바 메소드 참조는 함수형 인터페이스 내에서만 의미가 있지만, 호출 가능 참조는 일급 시민 식이다.
> - 호출 가능 참조는 함수나 프로퍼티의 애트리뷰트를 얻을 때 사용할 수 있는 리플렉션 객체이기도 하다.
> - 코틀린의 호출 가능 참조가 더 종류가 많다. (더 많은 타입 지원)

### 인라인 함수와 프로퍼티
함숫값을 사용하는 고차 함수를 호출하는 부분을 해당 함수의 본문으로 대체할 때 inline 키워드를 사용한다.
- inline 키워드가 붙은 함수는 가능하면 항상 인라인이 되며, 인라인이 불가능한 경우에는 컴파일 오류로 간주된다.
- 인라인 함수는 파라미터로 넘어온 함수 또한 인라인으로 만든다. 따라서 인라인 함수는 변수에 저장되거나, 인라인 함수가 아닌 함수에 전달될 수 없다. 
- 특정 람다를 인라인 하지 말라고 파라미터 앞에 noinline 변경자를 붙일 수도 있다.
```kotlin
  inline fun forEach(a: IntArray, noinline action: ((Int) -> Unit)?) {
    if (action == null) return
    for (n in a) action(n)
  }  
```

인라인 함수에 비공개 멤버를 전달하는 것은 불가능하다.

프로퍼티 접근자를 인라인 하는 것 또한 가능하다. 이 때 프로퍼티 자체에 인라인을 걸면 게터와 세터 모두 인라인으로 바꿔준다.   

이러한 프로퍼티 인라인은 뒷받침하는 필드가 없을 때만 가능하다. 또한 함수와 비슷하게 공개 프로퍼티의 경우 게터, 세터 안에서 비공개 선언을 참조하면 인라인이 불가능하다.

### 비지역적 제어 흐름
```kotlin
fun forEach(a: IntArray, action: (Int) -> Unit) {
  for (n in a) action(n)
}

fun main(){
  forEach(intArrayOf(1, 2, 3, 4)) {
    if (it < 2 || it > 3) return
    println(it) //에러
  }
}
```

다음 코드를 실행하면 에러가 발생한다. 이유는 return 문이 의도는 람다를 리턴하는 것이지만 실제로는 main 함수를 반환하려 하기 때문이다. (return 문은 자신을 둘러싸고 있는 fun, get, set으로 정의된 가장 안쪽 함수로부터 제어 흐름을 변화시킨다.) 이를 비지역적 return이라고 부른다.

-> 이를 해결하는 방법은 람다 대신 익명 함수를 사용하는 것이다.

```kotlin
val action: (Int) -> Unit = myFun@ {
  if (it < 2 || it > 3) return@myFun
  println(it)
}
```
다음과 같이 람다 자체로부터 리턴하고 싶으면 레이블을 사용하면 된다.

```kotlin
forEach(intArray(1, 2, 3, 4)) {
  if (it < 2 || it > 3 return@forEach)
  println(it)
}
```
람다를 고차 함수의 인자로 넘기는 경우 레이블을 명시하지 않아도 함수 이름을 문맥으로 사용할 수 있다.   
이는 일반 함수에서도 가능하다.

## 5.2 확장
 코틀린에서는 마치 멤버인 것처럼 쓸 수 있는 함수나 프로퍼티를 클래스 밖에서 선언할 수 있게 해주는 확장이라는 기능을 제공한다.

 ### 확장 함수
 ```kotlin
 fun String.truncate(maxLength: Int): String {
  return if (length <= maxLength) this else substring(0, maxLength)
 }

 fun main() {
  println("Hello".truncate(10)) // Hello
  println("Hello).truncate(3) // Hel
 }
 ```

 다음과 같이 `{수신 객체 클래스}.{함수 이름}` 형태로 함수를 정의하고 본문을 작성하면 된다.
 이후 사용은 다음과 같이 하면 된다.

 확장 함수 안에서 this도 사용 가능하다. 그러나 수신 객체가 속한 클래스의 비공개 멤버에 대한 접근은 불가능하다.

따라서 클래스 본문 안에 확장 함수를 정의하면 비공개 멤버에도 접근 가능하게 된다.

클래스 멤버와 확장의 시그니처가 같다면 컴파일러는 멤버를 우선으로 한다.

### 확장 프로퍼티
```kotlin
val IntRange.leftHalf: IntRange
  get() = start..(start + endInclusive)/2

fun main() {
  println((1..3).leftHalf)
  println((3..6).leftHalf)
}
```

다음과 같이 프로퍼티도 확장 가능하다.

확장 프로퍼티에 뒷받침하는 필드를 쓸 수 없다. 즉 확장 프로퍼티를 초기화할 수 없고, 접근자 안에서 field를 사용할 수도 없다. 또한 lateinit으로 확장 프로퍼티를 정의할 수도 없다.

확장 프로퍼티 정의에서는 항상 명시적인 게터를 정의해야 하고, 가변 프로퍼티인 경우에는 세터도 정의해야 한다.