# 13 동시성 

## 13.1 코루틴

- 코틀린 프로그램에서도 자바 동시성 기본 요소를 쉽게 사용해 스레드 안정성을 달성할 수 있다.
- 하지만 자바 동시성 요소를 사용해도 대부분의 동시성 연산이 블러킹 연산이므로 여전히 몇 가지 문제가 남는다.
    - Thread.sleep(), Thread.join(), Object.wait()는 실행이 끝날 때까지 블럭된다.

> 동기/비동기 vs 블로킹/논블로킹
>
> - 동기 - 함수의 **작업 완료 여부를 누가 신경쓰느냐**가 관심사
    >     - 처리되는 작업의 요청과 결과가 한 자리에서 일어난다. 즉, 현재 처리되고 있는 작업의 요청이 모두 완료하여 응답을 리턴한 후에 다음 작업을 처리할 수 있다.
>     - **호출하는 함수**가 **호출된 함수**의 작업이 완료되었는지를 계속 신경쓰고 있다.
> - 비동기 - 함수의 **작업 완료 여부를 누가 신경쓰느냐**가 관심사
    >     - **호출하는 함수**가 **호출된 함수**의 작업 완료 여부를 신경쓰지 않는다. 호출하는 함수는 함수를 호출할 때 **callback 함수**를 같이 전달하고, 작업이 완료되면 **callback 함수**가 실행된다. 즉, **호출된 함수**가 수행결과와 종료를 직접 신경쓰고 처리한다.
>     - **Task1**이 완료여부에 상관 없이 **Task2**를 처리할 수 있다.
> - 블로킹 - 호출되는 함수가 **바로 return하느냐 마느냐**가 관심사
    >     - **호출된 함수**가 자신의 작업이 종료될 때까지 **제어권**을 갖고 있는 것을 말한다. 즉, **호출된 함수**의 작업이 종료될 때까지 **호출하는 함수**는 다른 작업을 진행할 수 없다.
> - 논블로킹 - 호출되는 함수가 **바로 return하느냐 마느냐**가 관심사
    >     - **호출된 함수**가 자신의 작업이 종료되지 않았더라도 함수의 제어권을 자신을 **호출하는 함수**로 바로 넘겨준다 (return). 이를 통해 **호출하는 함수**가 다른 일을 진행할 수 있다.
- 스레드를 블럭하고 나중에 실행을 재개하려면 시스템 수준에서 계산 비용이 많이 드는 문맥 전환을 해야 하므로 프로그램 성능에 부정적인 영향을 미칠 수 있다.
- 또한 동시성을 위해 스레드마다 상당한 양의 시스템 자원을 유지해야 하기 때문에 동시성 스레드를 아주 많이 사용하는 것은 비실용적이거나 불가능 할 수도 있다.
- 더 효율적인 접근 방법은 비동기 프로그래밍이다. 하지만 이 방법의 가장 큰 문제점은 일반적인 명령형 제어 흐름을 사용할 수 없어서 코드 복잡도가 늘어난다는 점이다.
- 코루틴을 사용하면 동기 코드를 컴파일러가 효율적인 비동기 계산으로 자동 변환해준다.

### 13.1.1 코루틴과 일시 중단 함수

- 전체 코루틴 라이브러리를 뒷받침하는 기본 요소는 일시 중단 함수다.
    - 이 함수는 일반적인 함수를 더 일반화해 함수 본문의 원하는 지점에서 함수에 필요한 모든 런타임 문맥을 저장하고 함수 실행을 중단한 다음, 나중에 필요할 때 다시 실행을 계속 진행할 수 있게 한 것이다.
    - 코틀린에서는 이런 함수에 suspend라는 변경자를 붙인다.

```kotlin
suspend fun foo() {
	println("Task started")
	delay(100)
	println("Task finished")
}
```

- delay() 함수는 Thread.sleep()과 비슷한 일을 하지만 delay()는 현재 스레드를 블럭시키지 않고 자신을 호출한 함수를 일시 중단 시키며 스레드를 다른 작업을 수행할 수 있게 풀어준다.
- 일시 중단 함수는 일시 중단 함수와 일반 함수를 원하는 대로 호출할 수 있다. 일시 중단 함수를 호출하면 해당 호출 지점이 일시 중단 지점이 된다.
    - 일시 중단 지점은 임시로 실행을 중단했다가 나중에 재개할 수 있는 지점을 말한다.
- 반면 일반 함수 호출은 일반 함수처럼 작동해서 함수 실행이 다 끝난 뒤 호출한 함수로 제어가 돌아온다.
- 코틀린에서 일반 함수가 일시 중단 함수를 호출하는 것을 금지한다.
- 일반 함수에서 일시 중단 함수를 호출하기 위해서는 코루틴 빌더를 사용해야한다.

### 13.1.2 코루틴 빌더

- launch() 함수는 코루틴을 시작하고, 코루틴을 실행 중인 작업의 상태를 추적하고 변경할 수 있는 Job 객체를 돌려준다.
    - 이 함수는 CoroutineScpoe.()→Unit 타입의 일시 중단 람다는 받는다. 이 람다는 새 코루틴의 본문에 해당한다.

```kotlin
fun main(){ //main이 suspend 함수가 아님
  val time = currentTimeMillis()
  
  GlobalScope.launch{
    delay(100)
    println("Task 1 finished in ${currentTimeMillis()-time} ms")
  }
  
  GlobalScope.launch{
      delay(100)
      println("Task 2 finished in ${currentTimeMillis()-time} ms")
  }
  
  Thread.sleep(200) 
}  

//결과
Task 2 finished in 176ms
Task 1 finished in 176ms
```

- 두 작업이 병렬적으로 실행되었음을 알 수 있다. 다만 실행 순서는 보장되지 않는다.
- main() 함수 자체는 Thread.sleep()을 통해 메인 스레드 실행을 잠시 중단한다. 이를 통해 코루틴 스레드가 완료될 수 있도록 충분한 시간을 제공한다.
- 코루틴을 처리하는 스레드는 데몬 모드로 실행되기 때문에 main() 스레드가 이 스레드보다 빨리 끝나버리면 자동으로 실행이 종료된다.
- 코루틴은 스레드보다 훨씬 가볍다. 특히 코루틴은 유지해야 하는 상태가 더 간단하며 일시 중단되고 재개될 때 완전한 문맥 전환을 사용하지 않아도 되므로 엄청난 수의 코루틴을 충분히 동시에 실행할 수 있다.
- launch() 빌더는 동시성 작업이 결과를 만들어내지 않는 경우 적합하다. 그래서 이 빌더는 Unit 타입을 반환하는 람다를 인자로 받는다. 결과가 필요한 경우에는 async()라는 다른 빌더 함수를 사용해야 한다.
- async()는 Deferred의 인스턴스를 반환하고, 이 인스턴스는 Job 하위 타입으로 await() 메소드를 통해 계산 결과에 접근할 수 있게 해준다.
- await() 메소드를 호출하면 await()는 계산이 완료되거나 계산 작업이 취소될 때까지 현재 코루틴을 일시 중단시킨다. 작업이 취소되는 경우 await()는 예외를 발생시키면서 실패한다.
- async()를 자바의 퓨저에 해당하는 코루틴 빌더라고 생각할 수 있다.

```kotlin
suspend fun main(){
  val message = GlobalScope.async{
    delay(100)
    "abc"
  }
  
  val count = GlobalScope.async{
    delay(100)
    1 + 2
  }
  
  delay(200)
  
  val result = message.await().repeat(count.await())
  println("result")
}
```

- launch()와 async() 빌더의 경우 스레드 호출을 블럭시키지는 않지만, 백그라운드 스레드를 공유하는 풀을 통해 작업을 실행한다.
- runBlocking() 빌더는 디폴트로 현재 스레드에서 실행되는 코루틴을 만들고 코루틴이 완료될 때까지 현재 스레드의 실행을 블럭시킨다.
    - 코루틴이 성공적으로 끝나면 일시 중단 람다의 결과가 runBlocking() 호출의 결괏값이 된다. 코루틴이 취소되면 예외를 던진다.
    - 블럭된 스레드가 인터럽트되면 runBlocking()에 의해 시작된 코루틴도 취소된다.
    - runBlocking()은 다른 코루틴 안에서 사용하면 안된다.
    - runBlocking()은 블러킹 호출과 넌블러킹 호출 사이의 다리 역할을 하기 위해 고안된 코루틴 빌더이므로 테스트나 메인 함수에서 최상위 빌더로 사용하는 등의 경우에만 사용해야 한다.

### 13.1.3 코루틴 영역과 구조적 동시성

- 전역 영역이란 코루틴의 생명 주기가 전체 애플리케이션의 생명 주기에 의해서만 제약되는 영역이다.
- 구조적 동시성은 코투린을 다른 코루틴 문맥에서 실행하는 경우 생명 주기가 연관되는 것을 말한다.
    - A 코루틴을 B 코루틴에서 실행하면 A의 실행이 모두 끝나야 B가 끝날 수 있도록 생명 주기가 연관된다.
- coroutineScope() 호출로 코드 블록을 감싸면 커스텀 영역을 도입할 수 있다.
- coroutineScope()는 람다의 결과를 반환하고, 자식들이 완료되기 전까지 실행이 완료되지 않는다.
- coroutineScope()는 runBlocking()의 가장 큰 차이는 coroutineScope()가 일시 중단 함수라 현재 스레드를 블럭시키지 않는다는 점이다.
- 일반적으로 부모 자식 관계는 예외 처리와 취소 요청을 공유하는 영역을 정의하는 더 복잡한 코루틴 계층 구조를 만들어낼 수 있다.

### 13.1.4 코루틴 문맥

- 코루틴마다 CoroutineContext 인터페이스로 표현되는 문맥이 연관돼 있으며, 코루틴을 감싸는 변수 영역의 coroutineContext 프로퍼티를 통해 이 문맥에 접근할 수 있다.
- 코루틴 문맥은 키-값 쌍으로 이뤄진 불변 컬렉션이며, 코루틴에서 사용할 수 있는 여러 가지 데이터가 들어있다. 이 데이터 중 두 가지 요소에 주목해야한다.
    - job : 코루틴이 실행 중인 취소 가능한 작업을 표현
    - dispatcher : 코루틴과 스레드의 연관을 제어하는 디스패처
- 일반적으로 문맥은 CoroutineContext.Element를 구현하는 아무 데이터나 저장할 수 있다. 특정 원소에 접근하려면 get() 메서드나 인덱스 연산자에 키를 넘겨야 한다.

```kotlin
GlobalScope.lauch{
  println("Task is active: ${coroutineContext[Job.Key]!!.isActive}")
}
```

- 기본적으로 launch(), async() 등의 표준 코루틴 빌더에 의해 만들어지는 코루틴은 현재 문맥을 이어받는다.
- 필요하면 빌더 함수에 context 파라미터를 지정해 새 문맥을 넘길 수도 있다.
- 새 문맥을 만들려면 plus() 또는 + 연산사를 사용하거나 minusKey()를 통해 주어진 키에 해당하는 원소를 문맥에서 제거하면 된다.

```kotlin
private fun CoroutineScope.showName(){
  println("Current coroutine: ${coroutineContext[CoroutineName]?.name}")
}

fun main(){
  runBlocking{
    showName() // Current coroutine: null
    launch(coroutineContext + CoroutineName("worker")) {
      showName() // Current coroutine: Worker
    }
  }
}
```

- 코루틴을 실행하는 중간에 withContext()에 새 문맥과 일시 중단 람다를 넘겨서 문맥을 전환시킬 수도 있다.

## 13.2 코루틴 흐름 제어와 잡 생명 주기

- 잡은 동시성 작업의 생명 주기를 표현하는 객체이다.
- 잡을 사용하면 작업 상태를 추적하고 필요할 때 작업을 취소할 수 있다.

![1_Phk4n0BgK6092c7D7-F2Pg](https://github.com/To-Be-God/The-Complete-Guide-to-Kotlin/assets/78543382/822ecf12-b737-4b24-8132-e797b26a0165)

- 활성화 상태는 작업이 시작됐고 아직 완료나 취소로 끝나지 않았다는 뜻이다. 이 상태가 보통 디폴트 상태다. 즉, 잡은 생성되자마자 활성화 상태가 된다.
- launch(), async()는 CoroutineStart 타입의 인자를 지정해서 잡의 초기 상태를 선택하는 기능을 제공하기도 한다.
    - CoroutineStart.DEFAULT : 즉시 시작 (DEFAULT)
    - CoroutineStart.LAZY : 자동으로 시작 X. 잡이 신뉴 상태가 되고 시작을 기다림
- 신규 상태의 잡에 대해 start(), join() 메소드를 호출하면 잡이 시작되면서 활성화 상태가 된다.

```kotlin
fun main(){
  runBlocking{
  /**
  시작 기다림 따라서 자식 코루틴의 시작을 부모 코루틴이 메시지를 호출한 뒤로 미룬다
  **/
    val job = launch(start = CoroutineStart.LAZY){ 
      println("Task started")
    }
 
    delay(1000)
    
    println("Preparing to start...")
    job.start() // 부모 코루틴이 명시적으로 start() 호출
  }
}
```

- 활성화 상태에서는 코루틴 장치가 잡을 반복적으로 일시 중단하고 재개시킨다.
- 잡이 다른 잡을 실행시킬 수 있는데, 이 경우 새 잡은 기존 잡의 자식이 된다. 따라서 잡의 부모 자식 관계는 동시성 계산 사이에 트리 형태의 의존 구조를 만든다.
- children 프로퍼티를 통해 완료되지 않은 자식 잡들을 얻을 수 있다.
- 코루틴은 일시 중단 람다 블록의 실행이 끝나면 잡의 상태는 **완료 중** 상태로 바뀐다. 이 상태는 기본적으로 자식들의 완료를 기다리는 상태다. 잡은 모든 자식이 완료될 때까지 이 상태를 유지하고, 모든 자식이 완료되면 잡의 상태가 **완료 중**에서 **완료됨**으로 바뀐다.
- 잡에 join() 메소드를 사용하면 조인 대상 잡이 완료될 때까지 현재 코루틴을 일시 중단시킬 수 있다.
- 현재 잡 상태를 잡의 isActive, isCancelled, isCompleted 프로퍼티를 통해 추적할 수 있다.

| 잡 상태 | isActive | isCompleted | isCancelled |
| --- | --- | --- | --- |
| 신규 | false | false | false |
| 활성화 | true | false | false |
| 완료 중 | true | false | false |
| 취소 중 | false | false | true |
| 완료 | false | true | false |
| 취소 | false | true | true |

### 13.2.1 취소

- 잡의 cancel() 메소드를 호출하면 잡을 취소할 수 있다.
- 이 메서드는 더 이상 필요 없는 계산을 중단시킬 수 있는 표준적인 방법을 제공한다.
- 취소 가능한 코루틴은 스스로가 취소가 요청됐는지 검사해서 적절히 반응해줘야 한다. 검사하는 방법은 다음과 같이 2가지 방법이 있다.
    - isActive 확장 프로퍼티를 사용해 현재 잡이 활성화 상태인지 검사.
    - CancellationException을 통해서 취소에 반응할 수 있게 일시 중단 함수를 호출.
        - 이는 잡을 취소하는 과정이 진행 중이라는 사실을 전달하는 토큰 역할을 하기 위해 코루틴 라이브러리 내부에서 쓰이는 예외이다.
        - delay()나 join() 등의 모든 일시 중단 함수가 이 예외를 발생시켜준다.
- 부모 코루틴이 취소되면 자동으로 모든 자식의 실행을 취소합니다. 이는 부모에게 속한 모든 잡 계층이 취소될 때까지 계속된다.

### 13.2.2 타임아웃

- 경우에 따라 작업이 완료되기를 무작정 기다릴 수 없어 타임아웃을 설정해야할 때 withTimeout()을 사용하면 된다.
- 이 함수는 타임아웃이 발생하면 예외를 던진다.
- withTimeoutOrNull()은 예외 대신 널을 반환한다.

### 13.2.3 코루틴 디스패치하기

- 코루틴은 스레드와 무관하게 일시 중단 가능한 계산을 구현할 수 있게 해주지만, 코루틴을 실행하려면 여전히 스레드와 연관시켜야 합니다.
- 특정 코루틴을 실행할 때 사용할 스레드를 제어하는 작업을 담당하는 특별한 컴포넌트가 존재하고, 이를 디스패처라고 부른다.
- 디스패처는 코루틴 문맥의 일부이다. 따라서 launch()나 runBlocking() 등의 코루틴 빌더 함수에서 이를 지정할 수 있다.
- 디스패터는 그 자체로 원소가 하나뿐인 문맥이기도 하므로, 코루틴 빌더에 디스패처를 넘길 수 다.

```kotlin
fun main(){
  runBlocking{
  // 전역 스레드 풀 디스패처를 사용
    launch(Dispatcher.Default){
      println(Thread.currentThread().name)
    }
  }
}
```

- 코루틴 디스패처는 병렬 작업 사이에 스레드를 분배해주는 자바 실행기와 비슷하다.
- 실행하는 스레드에 이름을 부여하는 커스텀 스레드 팩토리를 사용할 수도 있다.

    ```kotlin
    val executor = ScheduledThreadPoolExecutor(5) { runnable -> 
    	Thread(
    		runnable,
    		"WorkerThread-${id.incrementAngGet()}"
    		).alse {it.isDaemon = true}
    	}
    	
    	executor.asCoroutineDispatcher().use { dispatcher ->
    		runBlocking {
    			for (i in 1..3) {
    				launch(dispatcher) {
    					println(Thread.currentThread().name)
    					delay(1000)
    					...
    ```

- ExecutorService의 인스턴스에 asCoroutineDispatcher()를 호출하면 ExecutorCoroutine Dispatcher를 반환하는데, 이 디스패터는 Closeable 인스턴스도 구현한다.
- 이 디스패처의 바탕이 되는 실행기 서비스를 종료하고 스레드를 유지하기 위해 할당했던 시스템 자원을 해체하려면 close() 함수를 직접 호출하거나, 방금 본 코드처럼 use() 함수 블록 안에서 디스패처를 사용해야 한다.
- 코루틴 라이브러리는 기본적으로 다음과 같은 디스패처 구현을 제공한다.
    - Dispatchers.Default : 공유 스레드 풀로 CPU 위주의 작업에 적합
    - Dispatchers.IO : 스레드 풀기반으로 I/O 를 많이 사용하는 작업에 최적화
    - Dispatchers.Main : UI 스레드에서만 배타적으로 작동하는 디스패처
- 디스패처를 명시적으로 지정하지 않으면 코루틴을 시작한 영역으로 디스패처가 자동으로 상속된다.
- 코루틴 생명 주기 내내 같은 디스패처를 사용할 필요도 없다. 디스패처가 코루틴 문맥의 일부이므로 withContext() 함수를 사용해 디스패처를 오버라이드할 수 있다.

### 13.2.4 예외 처리

- 예외 처리의 경우, 코루틴 빌더들은 두 가지 기본 전략 중 하나를 따른다.
    1. **launch() 같은 빌더가 선택한 전략으로 예외를 부모 코루틴에 전달하는 방법. 이 경우 예외는 다음과 같이 전파된다.**
    - 부모 코루틴이 똑같은 오류로 취소된다. 이로 인해 부모의 나머지 자식도 모두 취소된다.
    - 자식들이 모두 취소되고 나면 부모는 예외를 코루틴 트리의 윗부분으로 전달한다.
    - 전역 영역에 있는 코루틴에 도착할 때까지 이 과정이 반복된다.

    ```kotlin
    fun main(){
      runBlocking{
        launch{
          throw Exception("Error in task A")
          println("Task A completed")
        }
        
        launch{
          delay(1000)
          println("Task B completed")
        }
        
        println("Root")
      }
    }
    ```

    - 최상위 코루틴은 한 쌍의 내부 작업을 시작한다. 그중 첫 번째 코루틴은 예외를 던진다.
    - 이로 인해 최상위 작업이 취소되고, 최상위 자식인 두 작업도 취소된다.
    - 그리고 최상위에서 아무 커스텀 핸들러도 지정하지 않았기에 Thread.uncaughtExceptionHandler에 등록된 디폴트 동작을 실행한다. 그에 따라 다음과 같은 메시지가 표시되고, 그 뒤에 예외에 대한 스텍 트레이스가 출력된다.

        ```kotlin
        Root
        Exception in thread "main" ~ Exception: Error in task A
        ```

    - CoroutineExceptionHandler는 현재 코루틴 문맥과 던져진 예외를 인자로 전달받는다.
    - 핸들러를 만드는 가장 간단한 방법은 인자가 두 개인 람드를 받는 CoroutineExceptionHandler()를 사용하는 것이다.
    - 이 핸들러의 인스턴스가 예외를 처리하도록 지정하려면 코틀린 문맥에 인스턴스를 넣어야 한다. 핸들러 또한 코루틴 문맥이므로 코루틴 빌더의 context 인자로 핸들러를 넘길 수 있다.
    - CoroutineExceptionHandler는 전역 영역에서 실행된 코루틴에 대해서만 정의할 수 있고, CoroutineExceptionHandler가 정의된 코루틴의 자식에 대해서만 적용된다.

    1. **async() 빌더에서 사용하는 방법으로, 던져진 예외를 저장했다가 예외가 발생한 계산에 대한 await() 호출을 받았을 때 다시 던지는 방법**
    - 코루틴 데이터에 접근할 때 예외를 다시 던지는 방식을 채용하는 async와 유사한 빌더들의 경우 CoroutineExceptionHandler를 사용하지 않는다.
    - try-catch를 사용하더라도 자식이 실패한 경우 부모를 취소시키기 위해 자동으로 예외를 다시 던지기 때문에 이 동작을 변경하려면 슈퍼바이저 잡을 사용해야 합니다.
    - 슈퍼바이저 잡이 있으면 취소가 아래 방향으로만 전달된다. 하지만 슈퍼바이저가 아니라 자식이 취소된 경우, 슈퍼바이저나 슈퍼바이저의 다른 자식들은 아무 영향을 받지 않는다.
    - 부모 코루틴을 슈퍼바이저로 변환하려면 coroutineScope() 대신 supervisorScope()를 사용하면 된다.
    - 슈퍼바이저의 동작은 일반적인 취소에도 적용된다. 슈퍼바이저의 자식 중 하나에 cancel()을 호출해도 해당 코루틴의 형제자매나 슈퍼바이저 자신에게는 아무 영향이 없다.