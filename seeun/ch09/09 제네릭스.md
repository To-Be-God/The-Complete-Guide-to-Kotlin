# 09 제네릭스

## 9.1 타입 파라미터

### 9.1.1 제네릭 선언

- 어떤 선언을 제네릭 선언으로 만들려면 하나 이상의 타입 파라미터를 추가해야 한다. 이 타입 파라미터를 선언 내부에서는 일반적인 타입 대신 사용할 수 있다.
- 선언을 사용할 때는 타입 파라미터를 대신할 실제 타입을 지정해야 한다.

    ```kotlin
    val map = HashMap<Int, String>()
    val list = arrayListOf<String>()
    ```

- 제네릭 클래스나 인터페이스를 사용해 데이터의 타입을 지정할 때는 반드시 타입 인자를 명시해야 한다.
- 제네릭 클래스 생성자를 호출할 때 타입 인자가 불필요한 경우가 있는데, 대부분의 경우 컴파일러가 문맥에서 타입 인자를 추론해준다. 다만 상위 클래스 생성자에 대한 위임 호출은 예외다.
    - 위임 호출 시 타입 파라미터는 상속하지 않는다는 사실을 유의하라.
- 제네릭 클래스에서 정의된 함수와 프로퍼티에서 클래스의 타입 파라미터를 사용할 수 있다. 또한, 프로퍼티나 함수에 타입 파라미터를 추가하면 프로퍼티나 함수 자체를 제네릭으로 만들 수 있다.
    - 제네릭 클래스에서와 달리 프로퍼티나 함수를 제네릭으로 선언할 때는 타입 파라미터를 fun이나 val/var 바로 뒤에 위치시킨다는 점을 유의하라.
- 프로퍼티 참조는 타입 인자를 지원하지 않는다. 따라서 제네릭 프로퍼티의 타입 파라미터는 수신 객체 타입으로부터 추론돼야 한다. 제네릭 프로퍼티를 선언하면서 타입 파라미터를 사용하지 않는 경우에도 컴파일 시점 오류가 발생한다.

### 9.1.2 바운드와 제약

- 기본적으로 타입 인자로 들어갈 수 있는 타입에는 아무런 제약이 없다. 따라서 타입 파라미터들은 Any? 타입과 동의어인 것처럼 처리된다.
- 제네릭 클래스를 구현하면서 다뤄야 할 데이터의 타입에 좀 더 많은 정보가 필요한 경우 타입 파라미터의 상위 바운드를 선언할 수 있다.
- 타입 파라미터에 상위 바운드가 있으면 컴파일러는 이 타입 파라미터에 공급된 타입 인자의 타입이 상위 바운드의 하위 타입인지를 검사한다.
- 타입 파라미터 바운드로 타입 파라미터를 사용할 수도 있으며, 이런 경우를 재귀적 타입 파라미터라고 말한다.
- 바운드가 자신보다 앞에 있는 타입 파라미터를 가리킬 수도 있다. 이런 바운드를 사용해 트리 원소를 가변 리스트에 추가하는 함수를 정의할 수 있다.

    ```kotlin
    // U가 T의 하위 타입
    fun <T, U:T> TreeNode<U>.toList(list: MutableList<T>) {
    	walkDepthFirst{ list += it }
    }
    
    fun main() {
    	val list = ArrayList<Number>()
    	
    	TreeNode(1).apply {
    		addChild(2)
    		addChild(3)
    	}.toList(list)
    	
    	TreeNode(1.0).apply {
    		addChild(2.0)
    		addChild(3.0)
    	}.toList(list)
    	
    //Int 트리나 Double 트리에 있는 원소들을 Number 타입의 리스트에 추가할 수 있다
    ```

- 타입 파라미터 구문을 사용하면 상위 바운드를 하나만 지정할 수 있다. 하지만 한 타입 파라미터에 여러 제약을 가할 필요가 있을 때도 있다. 이때 where 절을 사용한다.

### 9.1.3 타입 소거와 구체화

- 코틀린 또한 자바와 같은 타입 소거 문제가 발생한다.
- 코틀린에서는 구체화를 통해 이 문제를 해결할 수 있다.
    - 인라인한 함수에 대해서만 구체화한 타입 파라미터를 사용할 수 있고, 인라인 함수는 함수 본문을 호출 위치로 인라인시키기 때문에 컴파일러가 인라인된 함수에 제공되는 타입 인자의 실제 타입을 항상 알 수 있다.
- 파라미터를 구체화하려면 reified 키워드로 해당 타입 파라미터를 지정해야 한다.
- 자바와 달리 구체화한 타입 파라미터를 사용하면 안전하고 빠르다. 다만 컴파일된 코드의 크기가 커지는 경향이 있다는 점을 조심해야 한다.