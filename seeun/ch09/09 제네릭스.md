# 09 제네릭스

## 9.1 타입 파라미터

### 9.1.1 제네릭 선언

- 어떤 선언을 제네릭 선언으로 만들려면 하나 이상의 타입 파라미터를 추가해야 한다. 이 타입 파라미터를 선언 내부에서는 일반적인 타입 대신 사용할 수 있다.
- 선언을 사용할 때는 타입 파라미터를 대신할 실제 타입을 지정해야 한다.

    ```kotlin
    val map = HashMap<Int, String>()
    val list = arrayListOf<String>()
    ```

- 제네릭 클래스나 인터페이스를 사용해 데이터의 타입을 지정할 때는 반드시 타입 인자를 명시해야 한다.
- 제네릭 클래스 생성자를 호출할 때 타입 인자가 불필요한 경우가 있는데, 대부분의 경우 컴파일러가 문맥에서 타입 인자를 추론해준다. 다만 상위 클래스 생성자에 대한 위임 호출은 예외다.
    - 위임 호출 시 타입 파라미터는 상속하지 않는다는 사실을 유의하라.
- 제네릭 클래스에서 정의된 함수와 프로퍼티에서 클래스의 타입 파라미터를 사용할 수 있다. 또한, 프로퍼티나 함수에 타입 파라미터를 추가하면 프로퍼티나 함수 자체를 제네릭으로 만들 수 있다.
    - 제네릭 클래스에서와 달리 프로퍼티나 함수를 제네릭으로 선언할 때는 타입 파라미터를 fun이나 val/var 바로 뒤에 위치시킨다는 점을 유의하라.
- 프로퍼티 참조는 타입 인자를 지원하지 않는다. 따라서 제네릭 프로퍼티의 타입 파라미터는 수신 객체 타입으로부터 추론돼야 한다. 제네릭 프로퍼티를 선언하면서 타입 파라미터를 사용하지 않는 경우에도 컴파일 시점 오류가 발생한다.

### 9.1.2 바운드와 제약

- 기본적으로 타입 인자로 들어갈 수 있는 타입에는 아무런 제약이 없다. 따라서 타입 파라미터들은 Any? 타입과 동의어인 것처럼 처리된다.
- 제네릭 클래스를 구현하면서 다뤄야 할 데이터의 타입에 좀 더 많은 정보가 필요한 경우 타입 파라미터의 상위 바운드를 선언할 수 있다.
- 타입 파라미터에 상위 바운드가 있으면 컴파일러는 이 타입 파라미터에 공급된 타입 인자의 타입이 상위 바운드의 하위 타입인지를 검사한다.
- 타입 파라미터 바운드로 타입 파라미터를 사용할 수도 있으며, 이런 경우를 재귀적 타입 파라미터라고 말한다.
- 바운드가 자신보다 앞에 있는 타입 파라미터를 가리킬 수도 있다. 이런 바운드를 사용해 트리 원소를 가변 리스트에 추가하는 함수를 정의할 수 있다.

    ```kotlin
    // U가 T의 하위 타입
    fun <T, U:T> TreeNode<U>.toList(list: MutableList<T>) {
    	walkDepthFirst{ list += it }
    }
    
    fun main() {
    	val list = ArrayList<Number>()
    	
    	TreeNode(1).apply {
    		addChild(2)
    		addChild(3)
    	}.toList(list)
    	
    	TreeNode(1.0).apply {
    		addChild(2.0)
    		addChild(3.0)
    	}.toList(list)
    	
    //Int 트리나 Double 트리에 있는 원소들을 Number 타입의 리스트에 추가할 수 있다
    ```

- 타입 파라미터 구문을 사용하면 상위 바운드를 하나만 지정할 수 있다. 하지만 한 타입 파라미터에 여러 제약을 가할 필요가 있을 때도 있다. 이때 where 절을 사용한다.

### 9.1.3 타입 소거와 구체화

- 코틀린 또한 자바와 같은 타입 소거 문제가 발생한다.
- 코틀린에서는 구체화를 통해 이 문제를 해결할 수 있다.
    - 인라인한 함수에 대해서만 구체화한 타입 파라미터를 사용할 수 있고, 인라인 함수는 함수 본문을 호출 위치로 인라인시키기 때문에 컴파일러가 인라인된 함수에 제공되는 타입 인자의 실제 타입을 항상 알 수 있다.
- 파라미터를 구체화하려면 reified 키워드로 해당 타입 파라미터를 지정해야 한다.
- 자바와 달리 구체화한 타입 파라미터를 사용하면 안전하고 빠르다. 다만 컴파일된 코드의 크기가 커지는 경향이 있다는 점을 조심해야 한다.

## 9.2 변성

- 변성은 타입 파라미터가 달라질 때 제네릭 타입의 하위 타입 관계가 어떻게 달라지는지를 설명하는 제네릭 타입의 한 측면이다.
  - String은 Any의 하위 타입이다.
  - 배열과 가변 컬렉션의 타입 인자로 들어가는 경우에는 하위 타입 관계를 유지하지 않는다.
  - 반대로 List나 Set 같은 불변 컬렉션의 경우, 타입 파라미터의 하위 타입 관계가 컬렉션 타입에서도 유지된다.
- 변성을 합리적으로 사용하면 타입 안전성을 해치지 않으면서 API 유연성을 향상시킬 수 있다.

### 9.2.1 변성 : 생산자와 소비자 구분

- 디폴트로 어떤 제네릭 타입의 타입 인자를 서로 다른 타입으로 대치한 타입들은 서로 하위 타입 관계가 없는 것으로 간주된다. 타입 인자들 사이에 하위 타입 관계가 있는 경우에도 역시 서로 아무 관계도 없는 타입인 것으로 간주된다.
  - 이런 경우 해당 제네릭 타입이 무공변이라고 말한다.
    - 공변 : 타입 파라미터의 상하위 타입 관계에 따라 제네릭 타입의 상하위 타입 관계가 함께 변한다는 뜻이다. 이런 경우 타입 파라미터의 상하위 타입 관게에 따라 제네릭 타입의 상하위 타입 관계가 정해진다.
- 반면 불변 컬렉션 같은 어떤 제네릭 타입들은 타입 인자 사이에 하위 타입 관계가 그대로 제네릭 타입에서도 유지된다.
- 이런 구분은 자신의 타입 파라미터를 취급하는 방법에 달려 있다. 모든 제네릭 타입은 세 가지로 나뉜다.
  - T 타입의 값을 반환하는 연산만 제공하고 T타입의 값을 입력으로 받는 연산은 제공하지 않는 제네릭 타입인 생산자
  - T 타입의 값을 입력으로 받기만 하고 결코 T 타입의 값을 반환하지는 않는 제네릭 타입인 소비자
  - 위 두 가지 경우에 해당하지 않는 나머지 타입들
- 생산자도 소비자도 아닌 타입들의 경우 안정성을 깨지 않고는 하위 타입 관계를 유지할 수 없다.

    ```kotlin
    // TreeNode<String>이 TreeNode<Any>의 하위 타입 관계가 성립한다고 가정
    val stringNode = TreeNode<String>("Hello")
    val anyNode: TreeNode<Any> = stringNode
    // stringNode를 anyNode에 대입하고 나면 Int를 String 타입의 트리에 대입할 수 있게 된다. 
    anyNode.addChild(123)
    // String으로 캐스트할 때 예외 발생
    val s = stringNode.children.first() 
    ```

- **생산자, 소비자와 공변의 관계성**
  - 불변 컬렉션은 T 타입의 값을 만들어내기만 하고 결코 소비하지 않는다. (생산자)
    - List<Any>는 Any 타입의 값을 돌려주고 List<String>은 String 타입의 값을 돌려준다. String이 Any의 하위 타입이기 때문에 String 타입의 값을 돌려주는 List<String>은 자동적으로 Any 타입의 값을 돌려줄 수 있기 때문에 공변적이다.
    - 공변성이 불변성과 같은 것은 아니다. 원소를 새로 추가할 수 없는 가변 타입을 만들면 그 또한 공변적으로 작동한다.
    - 불변이어도 생산자가 아니면 하위 타입 관계를 유지할 수 없다.
  - 소비자 역할을 하는 타입은 타입 파라미터의 하위 타입 관계를 유지해주지 못한다. 이런 타입은 타입 파라미터의 하위 타입 관계를 역방향으로 유지해준다.

      ```kotlin
      interface Set<T> {
          fun contains(element: T): Boolean
      }
      ```

    - Set<Number>는 아무 Number 값이나 처리할 수 있고, Set<Int>는 아무 Int값이나 처리할 수 있다.
    - 이때 Int는 Number의 하위 타입이다.
    - 따라서 Set<Number>은 아무 Int나 처리할 수 있다. 즉, Set<Number>는 Set<Int>의 하위 타입처럼 동작한다. 이를 반공변적이라 한다.
- 정리하면 다음과 같다.
  - X가 생산자 역할을 하는 경우 T를 공변적으로 선언할 수 있고, A가 B의 하위 타입이면 X<A>도 X<B>의 하위 타입이 된다.
  - X가 소비자 역할을 하는 경우 T를 반공변적으로 선언할 수 있고, B가 A의 하위 타입이면 X<A>가 X<B>의 하위 타입이 된다.
  - 나머지 경우, X는 T에 대해 무공변이다.

### 9.2.2 선언 지점 변성

- 디폴트로 타입 파라미터는 무공변으로 취급된다. 이 말은 제네릭 타입이 타입 파라미터의 하위 타입 관계를 유지하지 않는다는 뜻이다.
- 공변적으로 만들려면 타입 파라미터 앞에 out이라는 키워드를 붙이면 된다.
- 어떤 타입 파라미터가 항상 out 위치에서 쓰이는 경우에만 이 타입 파라미터를 공변적으로 선언할 수 있다. out 위치는 기본적으로 값을 만들어내는 위치다.
  - 프로퍼티나 함수의 반환값 타입이나 제네릭 타입의 공변적인 타입 파라미터 위치가 out 위치다.
- 제네릭 타입이 소비자 역할을 할 때 타입 파라미터를 in으로 표시할 수 있다. 이 말은 타입 파라미터가 out 위치에 전혀 사용되지 않는다는 뜻이다.
- 타입 파라미터를 in위치와 out 위치에 모두 사용하는 경우에는 타입 파라미터를 무공변으로 지정하는 수밖에 없다.

### 9.2.3 프로젝션을 사용한 사용 지점 변성

- 변성을 지정하는 다른 방법으로 제네릭 타입을 사용하는 위치에서 특정 타입 인자 앞에 in/out을 붙이는 방법이 있다.
- 일반적으로는 무공변인 타입이지만 문맥에 따라 생상자나 소비자로만 쓰이는 경우에 유용하다.

    ```kotlin
    // addSubtree() 함수 내부 맥락에서는 인자로 전달된 트리를 오직 소비자로만 사용
    fun <T> TreeNode<T>.addSubtree(node: TreeNodeM<out T>): TreeNode<T> {
    	val newNode = addChild(node.data)
    	...
    ```

- `TreeNode<out T>` 를 프로젝션한 타입이라 부른다. 프로젝션인 out T는 TreeNode의 실제 타입 인자를 알지는 못하지만 이 타입 인자가 T의 하위 타입이어야만 한다는 뜻이다.
- 프로젝션 타입 내에 소비자 역할을 하는 연산이 있긴 하지만, 사용하려고 시도하면 컴파일 오류가 발생한다.
- 비슷하게 in 프로젝션을 통해 타입을 소비자로만 사용하게 할 수도 있다.

### 9.2.4 스타 프로젝션

- *로 표시되는 스타 프로젝션은 타입 인자가 타입 파라미터의 바운드 안에서 아무 타입이나 될 수 있다는 사실을 표현한다.
- 스타 프로젝션을 사용하면 타입 인자가 중요하지 않거나 알려져 있지 않은 제네릭 타입을 간결하게 표현할 수 있다.
- 타입 파라미터에 바운드가 둘 이상 있다면 *로 명시적인 out 프로젝션을 대신할 수 없다.
- *와 명시적인 out의 또 다른 차이는 *를 선언 지점 변성이 붙은 타입 파라미터를 대신할 때 쓸 수 있다는 점에 있다.
- 반공변 위치(Consumer<*>)에 적용한 스타 프로젝션은 Nothing 타입을 인자로 저장한 것과 같다.
  - Nothing은 모든 타입의 하위 타입이기 때문

## 9.3 타입 별명

- 타입 별명 정의는 typealias 키워드로 이뤄지며, 그다음에 별명이 오고 = 기호 다음에 실제 타입이 온다.

    ```kotlin
    typealias IntPredicate = (Int) -> Boolean
    typealias IntMap = HashMap<Int, Int>
    ```

- 타입 별명도 제네릭 타입처럼 타입 파라미터를 포함할 수 있다. 특히 제네릭 클래스와 비슷한 방식으로 타입 별명을 정의할 수 있다.
- 또한 가시성을 사용해 보이는 영역을 제한할 수도 있다.
- 타입 별명은 최상위에만 선언할 수 있다. 또한 제네릭 타입 별명에 대해 제약이나 바운드를 선언할 수는 없다.
- 타입 별명은 새 타입을 도입하는 것이 아니라 기존 타입을 가리키는 새로운 방법을 추가해주는 것 뿐이다. 따라서 타입 별명과 원래 타입을 자유롭게 바꿔 쓸 수 있다.