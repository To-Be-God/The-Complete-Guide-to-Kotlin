# 12 자바 상호 운용성

## 12.1 자바 코드를 코틀린에서 사용하기

### 12.1.1 자바 메서드와 필드

- 대부분의 경우 자바 메서드를 코틀린 함수 처럼 노출시킬 수 있다.
- 캡슐화되지 않은 자바 필드를 코틀린에서는 뻔한 접근자가 있는 프로퍼티처럼 쓸 수 있다.

### 12.1.2 Unit과 void

코틀린에는 반환값이 없음을 나타내는 void 키워드가 없다. 따라서 자바 void 함수는 코틀린에서 Unit을 반환하는 함수로 보인다.

**연산자 관습**

- 몇몇 자바 메서드는 코틀린의 연산자 관습을 만족한다. 이런 자바 메서드에는 operator 키워드가 붙어있지 않지만, 코틀린에서는 이들을 마치 연산자 함수인 것처럼 연산자를 통해 사용할 수 있다. 하지만 중위 호출 문법을 자바 메서드에 적용할 수는 없다.

### 12.1.3 합성 프로퍼티

- 자바에는 합성 프로퍼티가 없고, 게터와 세터를 사용하는 일이 많다. 아로 인해 코틀린 컴파일러는 자바 게터나 세터를 일반적인 코틀린 프로퍼티처럼 쓸 수 있게 합성 프로퍼티를 노출시켜준다.
- 게터는 파라미터가 없는 메서드여야 하며, 메서드 이름이 get으로 시작해야 한다.
- 세터는 파라미터가 하나만 있는 메서드여야 하며, 메서드 이름이 set으로 시작해야 한다.
- 코틀린에서는 클래스의 인스턴스를 가변 프로퍼티가 정의된 것처럼 쓸 수 있다.
- 현재 코틀린은 쓰기 전용 필드를 제공하지 않으므로 자바 클래스에서 세터 메서드는 있지만 게터가 없는 경우에는 아무 프로퍼티도 노출되지 않는다.
- 다른 관습으로, 게터 이름이 is로 시작할 수도 있다. 이런 경우 합성 프로퍼티는 게터와 이름이 같다.
- 합성 프로퍼티 구문은 코틀린이 아닌 코드로 작성된 메서드에 대해서만 사용할 수 있다. 코틀린 소스코드에서 get/set으로 선언한 메서드를 합성 프로퍼티로 사용할 수는 없다.

### 12.1.4 플랫폼 타입

- 따라서 코틀린 컴파일러는 자바 코드가 노출하는 타입에 대한 널 안전성 검사를 완화시켜서, 자바 타입을 명확한 널 가능성이 지정되지 않은 타입인 것처럼 취급한다.
- 코틀린에서 자바 코드로부터 비롯된 객체는 플랫폼 타입이라는 특별한 타입에 속한다.
    - 플랫폼 타입은 널이 될 수 있는 타입이기도 하고 널이 될 수 없는 타입이기도 하며, 이런 타입에 대한 타입 안전성 보증은 기본적으로 자바와 동일하다.
    - 플랫폼 타입의 값을 널이 될 수 있는 문맥에서 사용해도 되고 널이 될 수 없는 문맥에서 사용해도 된다.
    - 널이 될 수 없는 문맥에서 사용할 경우 NPE가 발생할 수도 있다.
- 플랫폼 타입을 코틀린 소스코드에서 명시할 수 없다. 컴파일러만 플랫폼 타입을 구성할 수 있다.
- 플랫폼 타입의 식을 변수에 대입하거나 명시적인 타입을 지정하지 않고 함수에서 반환하면 플랫폼 타입이 전파된다.
- 타입을 명시적으로 지정하면 플랫폼 타입을 널이 될 수 있는 타입이나 널이 될 수 없는 타입으로 강제로 지정할 수 있다.

### 12.1.5 널 가능성 애너테이션

- 자바에서 널 안정성을 보장하는 일반적인 방법은 특별한 애너테이션을 쓰는 것이다.
- 코틀린 컴파일러도 이런 애너테이션 중 일부를 지원한다. 이 경우 해당 자바 타입은 코틀린에서 널이 될 수 있거나 널이 될 수 없는 타입 중 하나로 정해지며, 플랫폼 타입으로 지정되지 않는다.
- 코틀린 컴파일러가 지원하는 널 가능성 애너테이션으로는 다음과 같다.
    - @Nullable, @Notnull
    - 안드로이드 SDK
    - @Nonnull
- 타입 파라미터에 애너테이션이 붙지 않으면 코틀린 컴파일러는 플랫폼 타입을 사용한다.

### 12.1.6 자바/코틀린 타입 매핑

- 자바와 코틀린에서 비슷한 의미를 가지는 타입도 있다.
- 코틀린 컴파일러는 JVM 플랫폼에서 실행되도록 컴파일하는 경우, 자바 코드에 선언된 내용을 코틀린 코드에서 사용하거나 코틀린 코드에 선언된 타입을 자바 코드에서 사용할 때 서로 상응하는 타입을 상호 변환해준다.
- JVM에서 기본 코틀린 타입의 값은 값이 사용되는 방식에 따라 JVM 원시 타입이거나 원시 타입에 상응하는 박싱 타입이다.
    - Int? 타입은 자바의 int에서는 널을 표현할 방법이 없기 때문에 java.lang.Integer 인스턴스로 표현된다.
- 코틀린으로 매칭된 자바 클래스의 정적 멤버를 코틀린 쪽 동반 객체에서 직접 접근할 수 없다. 정적 멤버를 사용하려면 해당 자바 클래스의 전체 이름을 언급해야 한다.

    ```kotlin
    val n = java.lang.Long.bitCount(1234)
    ```

- 코틀린의 표준 컬렉션 타입은 java.util 패키지에 있는 상응하는 컬렉션 타입으로 매핑된다. 하지만 자바에서 코틀린 방향으로의 매핑은 플랫폼 타입을 만들어낸다.
    - 자바 컬렉션은 불변과 가변 구현이 같은 API를 사용하기 때문이다.
- 제네릭 타입의 매핑은 양 언어 제네릭 구문의 차이 때문에 단순하지만은 않는 변환이 필요하다.
    - 자바의 extends 와일드 카드 → 코틀린 공변 프로젝션
    - 자바의 super 와일드 카드 → 코틀린 반공변 프로젝션
    - 자바의 로우 타입 → 코틀린 스타 프로젝션
- 원시 타입으로 이뤄진 자바 배열은 박싱/언박싱을 피하기 위해 상응하는 특화된 코틀린 배열 클래스로 매핑된다.
- 다른 모든 배열은 Array<(out)T>라는 특별한 플랫폼 타입의 배열 인스턴스로 변환된다.

### 12.1.7 단일 추상 메서드 인터페이스

- 추상 메서드가 하나뿐인 자바 인터페이스가 있다면 이 인터페이스는 기본적으로 코틀린 함수 타입처럼 작동한다.
- 코틀린은 자바 SAM 인터페이스가 필요한 위치에 람다를 넘길 수 있게 지원한다. 이를 SAM 변환이라 한다.
- SAM 변환은 인터페이스에 대해서만 적용되고, 메서드가 하나뿐인 클래스에는 적용될 수 없다. 그리고 자바와 달리 코틀린 인터페이스에 대해서도 SAM 변환을 쓸 수 없다.

## 12.2 코틀린 코드 자바에서 사용하기

### 12.2.1 프로퍼티 접근

- 자바나 JVM에는 프로퍼티라는 개념이 없으므로 코틀린 프로퍼티를 자바에서 직접 접근할 수는 없다.
- 하지만 컴파일된 JVM 바이트코드에서는 각 프로퍼티가 접근자 메서드로 표현되니 때문에 자바 클라이언트는 다른 일반적인 메서드와 마찬가지 방법으로 이 접근자 메서드를 통해 프로퍼티에 접근할 수 있다 .
- 접근자의 시그니처는 다음 규칙에 따라 프로퍼티의 정의에서 만들어진다.
  - 게터는 파라미터가 없는 메서드이며 게터의 반환 타입은 원래의 프로퍼티 타입과 같다. 게터의 이름은 프로퍼티 이름의 첫 번째 글자를 대문자로 바꾼 다음, 앞에 get을 붙여서 생성된다.
  - 세터는 새로운 값에 해당하는 파라미터를 하나만 받는 메서드다. 세터의 이름은 프로퍼티 이름의 첫 번째 글자를 대문자로 바꾼 다음, 앞에 set을 붙여서 생성된다.

    ```kotlin
    class Persion(var name: String, val age: Int)
    
    public class Person {
     @NotNull
     public String getName() {...}
     public void setName(@NotNull String value) {...}
     public int getAge() {...}
    }
    ```

  - 자바 클라이언트 코드는 접근자 메서드를 통해 프로퍼티에 접근할 수 있다.
- 프로퍼티 이름이 is로 시작하는 경우 코틀린 컴파일러는 다른 명명 규칙을 사용한다.
  - 게터 이름은 프로퍼티와 같다.
  - 세터 이름은 맨 앞의 is를 set으로 바꾼 이름이다.
  - 이 관습은 Boolean 타입과 아무 관계가 없고 이름만 살펴본다는 점에 유의해야 한다.
- 코틀린 프로퍼티에서 뒷받침하는 필드가 필요한 경우, 컴파일러가 접근자 메서드와 함께 필드도 만들어준다. 하지만 기본적으로 이 필드는 비공개이기 때문에 게터 세터 코드 밖에서 필드에 접근할 수는 없다.
  - 경우에 따라 자바 클라이언트 쪽에 이 프로퍼티 빌드를 노출시켜야 할 때가 있는데, 이런 경우에는 @JvmField 애너테이션을 프로퍼티 앞에 넣으면 된다. 이 애너테이션을 붙이면 자바 소스코드에서 컴파일러가 생성해주는 필드에 접근할 수 있다.
  - 이 경우 접근자 메서드는 생성되지 않고 뒷받침하는 필드가 프로퍼티 자체와 동일한 가시성으로 만들어짐을 유의해야 한다.
  - 프로퍼티 접근자가 게터,세터 메서드에서 기본적인 역할만 구현하고 있다면 @JvmField 사용할 수 없다.
- 추상 프로퍼티나 열린 프로퍼티의 경우, 이 프로퍼티를 오버라이드 하는 쪽에서 커스텀 접근자를 만들 수도 있기 때문에 @JvmField를 사용할 수 없다.
- 뒷받침하는 필드를 노출하는 다른 방법으로 lateinit 프로퍼티를 활용하는 방법이 있다.
- 이 경우 접근자와 뒷받침하는 필드가 모두 프로퍼티와 동일한 가시성을 가진다.
- 객체에서 lateinit은 @JvmField 애너테이션이 붙은 필드와 비슷한 정적 필드를 생성한다. 하지만 lateinit 프로퍼티의 접근자는 인스턴스 메서드로 남는다.
  - lateinit 프로퍼티의 필드에 접근하는 경우와 접근자 메서드에 접근하는 경우 서로 다르다.

      ```kotlin
      object Application {
          lateinit var name: String
      }
      
      public class Main {
          public static void main(String[] args) {
              // 직접 프로퍼티 접근. 초기화하기 전이라서 null이 출력됨
              println(Application.name) // null
              // 접근자 호출(정적 접근이 아님)
              Application.INSTANCE.setName("Application1");
              
              // 직접 프로퍼티 접근(정적 접근)
              Application.name = "Applicaiton2"
          }
      }
      ```


### 12.2.2 파일 퍼사드와 최상위 선언

- 코틀린에서는 다른 선언 내부가 아니라 패키지 바로 아래에 두는 최상위 선언을 자주 사용한다.
- 자바와 JVM 플랫폼에서 일반적으로 모든 메서드는 어떤 클래스에 속해야만 한다. 이런 요구사항을 만족시키기 위해 코틀린 컴파일러는 최상위 함수와 프로퍼티를 자동으로 생성된 파일 퍼사드라는 클래스에 넣는다.
  - 기본적으로 퍼시드 클래스 이름은 소스코드 이름 뒤에 Kt를 덧붙인 이름이 된다.
- 퍼사드 클래스에는 최상위에 선언된 클래스가 들어가지 않는다. 클래스는 JVM과 자바에서 최상위 수준에 존재할 수 있다.
- 퍼사드 클래스에 생성된 메서드가 정적 메서드이므로 자바 코드에서 최상위 메서드에 접근할 때 퍼사드 클래스를 인스턴스화할 필요가 없다.

### 12.2.3 객체와 정적 멤버

- JVM에서 코틀린 객체 선언은 정적인 INSTANCE 필드가 있는 일반적인 클래스로 컴파일된다.
- 객체 함수나 프로퍼티 접근자를 정적 메서드로 만들려면 @JvmStatic 애너테이션을 사용한다.

### 12.2.4 노출된 선언 이름 변경하기

- @JvmName 애너테이션은 파일만 아니라 함수나 프로퍼티 접근자에도 적용할 수 있다. 이를 통해 함수나 프로퍼티 접근자 이름을 변경할 수 있다.
- 이 기능의 주된 용도는 코틀린에서는 올바를 선언이지만 자바에서는 금지된 선언이 되는 시그니처 충돌을 막는 것이다.

```kotlin
class Person(val firstName: String, val familyName: String)

val Person.fullName
	get() = "$firstName $familyName"
	
fun getFullName(person: Person): String {
	return "${person.familyName}, ${person.firstName}"
}
```

- JVM 상에서 프로퍼티와 함수가 똑같은 시그니처의 메서드를 만들어내고, 이로 인해 모호성이 생기기 때문에 컴파일러 에러 발생
- @JvmName을 사용하면 충돌이 일어나는 이름을 바꿔서 문제를 해결할 수 있다.

```kotlin
@JvmName("getFullNameFamilyFirst")
fun getFullName(person: Person): String {
	return... 
```

- @JvmName은 코틀린 함수 이름이 자바 키워드와 우연히 겹쳐서 자바 클라이언트가 해당 함수를 쓸 수 없는 경우에도 유용하다.

### 12.2.5 오버로딩한 메서드 생성하기

- 코틀린 함수에 디폴트 값이 지정된 경우, 함수 인자 중 일부를 생략할 수 있기 때문에 함수를 호출할 때 인자의 수가 달라질 수 있다.
- 하지만 자바에는 디폴트 값이라는 개념이 없고 디폴트 값을 사용하고 싶더라도 모든 인자를 넘겨야만 한다.
- 코틀린은 이에 대한 해법으로 @JvmOverloads 애너테이션을 제공한다.
- @JvmOverloads를 적용하면 원래 코틀린 함수 외에 오버로딩된 함수를 추가로 생성해준다.
  - 오버로딩된 첫 번째 함수는 마지막 파라미터를 제외한 나머지 인자를 받는 함수이며, 이 함수는 원래 함수의 마지막 파라미터를 디폴트 값으로 지정해준다.
  - 오버로딩된 두 번째 함수는 마지막 두 파라미터를 제외한 나머지 인자를 받는 함수이며, 이 함수는 원래 함수의 마지막 두 파라미터를 디폴트 값으로 지정해준다.
  - 오버로딩된 마지막 함수는 파라미터를 하나만 받고, 나머지 파라미터를 디폴트 값으로 적용해준다.

### 12.2.6 예외 선언하기

- 코틀린에서는 검사 예외 비검사 예외를 구분하지 않는다. 반면 자바는 이를 구분하고, 이로 인해 자바 코드와 충돌이 발생할 수 있다.
- 이를 해결하기 위해 @Throws 애너테이션을 사용하면 된다.

### 12.2.7 인라인 함수

- 코틀린에서 inline 변경자가 붙은 함수는 일반 메서드로 자바에 노출된다. 자바 코드에서 이런 메서드를 호출할 수 있지만, 이 경우 인라인 함수의 본문이 호출하는 자바 코드로 인라인되지는 않는다.
- 현재는 인라인을 사용하지 않고 타입 구체화를 구현할 방법이 없으므로 자바 코드에서 이런 함수를 호출하는 것이 불가능하다.

### 12.2.7 타입 별명

- 코틀린 타입 별명은 자바 코드에서 쓸 수 없다.
- 자바에서 볼 때 타입 별명을 참조하는 선언은 모두 원래 타입을 가리키는 것으로 보인다.