# 12 자바 상호 운용성

## 12.1 자바 코드를 코틀린에서 사용하기

### 12.1.1 자바 메서드와 필드

- 대부분의 경우 자바 메서드를 코틀린 함수 처럼 노출시킬 수 있다.
- 캡슐화되지 않은 자바 필드를 코틀린에서는 뻔한 접근자가 있는 프로퍼티처럼 쓸 수 있다.

### 12.1.2 Unit과 void

코틀린에는 반환값이 없음을 나타내는 void 키워드가 없다. 따라서 자바 void 함수는 코틀린에서 Unit을 반환하는 함수로 보인다.

**연산자 관습**

- 몇몇 자바 메서드는 코틀린의 연산자 관습을 만족한다. 이런 자바 메서드에는 operator 키워드가 붙어있지 않지만, 코틀린에서는 이들을 마치 연산자 함수인 것처럼 연산자를 통해 사용할 수 있다. 하지만 중위 호출 문법을 자바 메서드에 적용할 수는 없다.

### 12.1.3 합성 프로퍼티

- 자바에는 합성 프로퍼티가 없고, 게터와 세터를 사용하는 일이 많다. 아로 인해 코틀린 컴파일러는 자바 게터나 세터를 일반적인 코틀린 프로퍼티처럼 쓸 수 있게 합성 프로퍼티를 노출시켜준다.
- 게터는 파라미터가 없는 메서드여야 하며, 메서드 이름이 get으로 시작해야 한다.
- 세터는 파라미터가 하나만 있는 메서드여야 하며, 메서드 이름이 set으로 시작해야 한다.
- 코틀린에서는 클래스의 인스턴스를 가변 프로퍼티가 정의된 것처럼 쓸 수 있다.
- 현재 코틀린은 쓰기 전용 필드를 제공하지 않으므로 자바 클래스에서 세터 메서드는 있지만 게터가 없는 경우에는 아무 프로퍼티도 노출되지 않는다.
- 다른 관습으로, 게터 이름이 is로 시작할 수도 있다. 이런 경우 합성 프로퍼티는 게터와 이름이 같다.
- 합성 프로퍼티 구문은 코틀린이 아닌 코드로 작성된 메서드에 대해서만 사용할 수 있다. 코틀린 소스코드에서 get/set으로 선언한 메서드를 합성 프로퍼티로 사용할 수는 없다.

### 12.1.4 플랫폼 타입

- 따라서 코틀린 컴파일러는 자바 코드가 노출하는 타입에 대한 널 안전성 검사를 완화시켜서, 자바 타입을 명확한 널 가능성이 지정되지 않은 타입인 것처럼 취급한다.
- 코틀린에서 자바 코드로부터 비롯된 객체는 플랫폼 타입이라는 특별한 타입에 속한다.
    - 플랫폼 타입은 널이 될 수 있는 타입이기도 하고 널이 될 수 없는 타입이기도 하며, 이런 타입에 대한 타입 안전성 보증은 기본적으로 자바와 동일하다.
    - 플랫폼 타입의 값을 널이 될 수 있는 문맥에서 사용해도 되고 널이 될 수 없는 문맥에서 사용해도 된다.
    - 널이 될 수 없는 문맥에서 사용할 경우 NPE가 발생할 수도 있다.
- 플랫폼 타입을 코틀린 소스코드에서 명시할 수 없다. 컴파일러만 플랫폼 타입을 구성할 수 있다.
- 플랫폼 타입의 식을 변수에 대입하거나 명시적인 타입을 지정하지 않고 함수에서 반환하면 플랫폼 타입이 전파된다.
- 타입을 명시적으로 지정하면 플랫폼 타입을 널이 될 수 있는 타입이나 널이 될 수 없는 타입으로 강제로 지정할 수 있다.

### 12.1.5 널 가능성 애너테이션

- 자바에서 널 안정성을 보장하는 일반적인 방법은 특별한 애너테이션을 쓰는 것이다.
- 코틀린 컴파일러도 이런 애너테이션 중 일부를 지원한다. 이 경우 해당 자바 타입은 코틀린에서 널이 될 수 있거나 널이 될 수 없는 타입 중 하나로 정해지며, 플랫폼 타입으로 지정되지 않는다.
- 코틀린 컴파일러가 지원하는 널 가능성 애너테이션으로는 다음과 같다.
    - @Nullable, @Notnull
    - 안드로이드 SDK
    - @Nonnull
- 타입 파라미터에 애너테이션이 붙지 않으면 코틀린 컴파일러는 플랫폼 타입을 사용한다.

### 12.1.6 자바/코틀린 타입 매핑

- 자바와 코틀린에서 비슷한 의미를 가지는 타입도 있다.
- 코틀린 컴파일러는 JVM 플랫폼에서 실행되도록 컴파일하는 경우, 자바 코드에 선언된 내용을 코틀린 코드에서 사용하거나 코틀린 코드에 선언된 타입을 자바 코드에서 사용할 때 서로 상응하는 타입을 상호 변환해준다.
- JVM에서 기본 코틀린 타입의 값은 값이 사용되는 방식에 따라 JVM 원시 타입이거나 원시 타입에 상응하는 박싱 타입이다.
    - Int? 타입은 자바의 int에서는 널을 표현할 방법이 없기 때문에 java.lang.Integer 인스턴스로 표현된다.
- 코틀린으로 매칭된 자바 클래스의 정적 멤버를 코틀린 쪽 동반 객체에서 직접 접근할 수 없다. 정적 멤버를 사용하려면 해당 자바 클래스의 전체 이름을 언급해야 한다.

    ```kotlin
    val n = java.lang.Long.bitCount(1234)
    ```

- 코틀린의 표준 컬렉션 타입은 java.util 패키지에 있는 상응하는 컬렉션 타입으로 매핑된다. 하지만 자바에서 코틀린 방향으로의 매핑은 플랫폼 타입을 만들어낸다.
    - 자바 컬렉션은 불변과 가변 구현이 같은 API를 사용하기 때문이다.
- 제네릭 타입의 매핑은 양 언어 제네릭 구문의 차이 때문에 단순하지만은 않는 변환이 필요하다.
    - 자바의 extends 와일드 카드 → 코틀린 공변 프로젝션
    - 자바의 super 와일드 카드 → 코틀린 반공변 프로젝션
    - 자바의 로우 타입 → 코틀린 스타 프로젝션
- 원시 타입으로 이뤄진 자바 배열은 박싱/언박싱을 피하기 위해 상응하는 특화된 코틀린 배열 클래스로 매핑된다.
- 다른 모든 배열은 Array<(out)T>라는 특별한 플랫폼 타입의 배열 인스턴스로 변환된다.

### 12.1.7 단일 추상 메서드 인터페이스

- 추상 메서드가 하나뿐인 자바 인터페이스가 있다면 이 인터페이스는 기본적으로 코틀린 함수 타입처럼 작동한다.
- 코틀린은 자바 SAM 인터페이스가 필요한 위치에 람다를 넘길 수 있게 지원한다. 이를 SAM 변환이라 한다.
- SAM 변환은 인터페이스에 대해서만 적용되고, 메서드가 하나뿐인 클래스에는 적용될 수 없다. 그리고 자바와 달리 코틀린 인터페이스에 대해서도 SAM 변환을 쓸 수 없다.