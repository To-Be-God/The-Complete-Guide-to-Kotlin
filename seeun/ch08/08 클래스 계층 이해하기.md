# 08 클래스 계층 이해하기

## 8.1 상속

- 도메인 개념에 있는 is-a 관계를 표현하기 위해 대부분의 객체지향 언어는 상속이라는 개념을 사용한다.
- 자바와 마찬가지로 코틀린 클래스는 단일 상속만을 지원한다. 어떤 클래스의 상위 클래스를 명시하지 않으면 컴파일러는 자동으로 이 클래스가 내장 클래스인 Any를 상속하는 것으로 가정한다.

### 8.1.1 하위 클래스 선언

- 자바와 달리 코틀린에서는 `extends` 와 `implements` 와 같은 특별한 키워드 대신 `:` 으로 표시된다.
- `open` 키워드는 해당 클래스가 상속에 대해 열려 있다는 뜻이다. 즉, 해당 클래스를 상위 클래스로 지정할 수 있다는 것이다.
- 자바에서는 모든 클래스가 디폴트로 열려 있으며, 상속을 금지하려면 `final`을 명시해야 하는 반면, 코틀린에서는 디폴트가 final이다. 따라서 상속을 허용하려면 `open` 키워드가 필요하다.
- 또한 코틀린에서 멤버를 오버라이드하는 경우에는 `override` 키워드를 앞에 붙여야만 한다.
- 특정 클래스들은 상속을 제한적으로 지원한다.
    - 데이터 클래스는 항상 `final` 이며, `open` 으로 선언할 수 없다.
    - 인라인 클래스는 다른 클래스를 상속할 수도 없고, 다른 클래스의 상위 클래스 역할을 할 수도 없다.
- 상속이 제공하는 강력한 기능은 임의 다형성이다. 임의 다형성은 상위 클래스 멤버의 여러 다른 구현을 하위 클래스에서 제공하고 런타임에 실제 인스턴스가 속한 클래스에 따라 구현을 선택해주는 기능을 말한다.
    - 코틀린에서는 상위 클래스의 멤버를 오버라이드해서 임의 다형성을 달성할 수 있다.

    ```kotlin
    open class Vehicle {
      open fun start() {
        println("I'm moving")
      }
      fun stop() {
        println("Stopped")
      }
    }
    
    class Car: Vehicle() { 
       override fun start() {
         println("I'm riding")
       }
     }
    
    class Boat: Vehicle() {
      override fun start() {
        println("I'm sailing")
      }
    }
    ```

    - `Vehicele` 클래스는 `start()` 메서드의 공통 구현을 제공한다. 그리고 이를 상속한 클래스인 `Car` 와 `Boat` 는 `start()` 를 오버라이드한다.
    - `Vehicele` 타입에 대한 메서드 호출은 런타임에 그 인스턴스의 클래스가 무엇인지에 따라 달라진다.

        ```kotlin
        fun main() {
        	startAndStop(Car())
        	startAndStop(Boat())
        }
        ```

- 클래스 멤버는 `final` 이 아니라면 오버라이드할 수 있고 그에 따라 런타임에 인스턴스의 구체적인 타입에 따라 어떤 구현이 호출될지 결정할 수 있지만, 확장은 항상 정적으로 호출할 대상이 결정된다.

    ```kotlin
    open class Vehicle {
    	open fun start() {
    		println("I'm moving")
    	}
    }
    
    fun Vehicle.stop() {
    	println("Stopped moving")
    }
    
    class Car : Vehicle() {
     override fun start() {
       println("I'm riding")
     }
    }
    
    fun Car.stop() {
      println("Stopped riding")
    }
    
    fun main() {
    	val vehicle: Vehicle = Car()
    	vehicle.start() // I'm riding -> 클래스 멤버라 동적으로 결정이 가능 vehicle 변수의 런타임 타입
    	vehicle.stop() // stopped moving -> vehicle 변수의 정적 타입
    } 
     
    ```

- 오버라이드하는 멤버를 final로 선언하면 더 이상 하위 클래스가 이 멤버를 오버라이드할 수 없다.
- 불변 프로퍼티를 가변 프로퍼티로 오버라이드할 수 있다.
- 멤버의 영역을 하위 클래스의 영역으로만 제한하고 싶은 경우, `protected` 라는 키워드를 붙이면 된다.
- 함수나 프로퍼티를 오버라이드한 버전이 원래 버전을 재사용하고 싶은 경우 `super` 키워드를 붙이면 된다.

### 8.1.2 하위 클래스 초기화

- 하위 클래스의 인스턴스를 생성하는 동안에 프로그램은 상위 클래스에 정의된 초기화 코드를 호출해야 한다.
    - 상위 클래스에서 초기화하는 상태가 하위 클래스 코드가 사용할 환경이 되기 때문에 항상 상위 클래스 초기화를 먼저 시행해야 한다.
- 데이터를 상위 클래스 생성자에게 전달하는 방법은 상위 클래스에 생성자를 두거나, 자식 클래스에 부생성자를 두는 방법이 있다.
    - 부생성자를 사용하는 경우에는 `super` 키워드를 사용해야 한다.
- 자바와 달리 코틀린에서는 생성자 간의 호출이 생성자 본문에 들어가는 일이 결코 없기에 코틀린에서는 이를 위해 항상 위임 호출 구문을 사용해야 한다.
- 주생성자가 있으면 부생성자가 상위 클래스를 위임 호출할 수 없다.
- 상위 클래스가 여러 생성자를 제공하고 하위 클래스에서 상위 클래스의 생성자 중 둘 이상을 지원하고 싶을 때는 주 생성자를 선언하지 않고 부 생성자만 정의하면 된다.
- 상위 클래스를 초기화할 때 조심해야 할 부분은 this 누출 문제이다.
    - this 누출 문제는 하위 클래스가 초기화 되기 전에 상위 클래스에서 이미 정의된 메서드를 오버라이드하여 호출할 경우 예상하지 못한 결과가 반환되는 문제이다.
    - this 누출 문제는 코틀린에서 널이 될 수 없는 타입의 변수 값이 널이 될 수 있는 드문 경우이다.

### 8.1.3 타입 검사와 캐스팅

- 코틀린에서는 is 연산자를 통해서 타입 검사를 할 수 있다.
- is, !is 연산자의 왼쪽 피연산자의 정적 타입이 오른쪽에 오는 타입의 상위 타입인 경우에만 두 연산자를 사용할 수 있다.
- is 연산자와 instanceof 연산자는 매우 비슷하지만 instanceOf 연산자는 null에 대해 항상 false를 반환하지만,  is의 결과는 연산자 오른쪽에 있는 타입이 null이 될 수 있는지 여부에 따라 결과가 달라진다.
- is/!is 연산자를 사용하면 스마트 캐스트가 가능하다.
    - 컴파일러는 검사 시점과 사용 시점 사이에 변수가 변경되지 않는다고 확신할 때만 스마트 캐스트를 허용한다.
    - 먼저 프로퍼티나 커스텀 접근자가 정의된 변수에 대해서는 스마트 캐스트를 쓸 수 없다.
    - 열린 멤버 프로퍼티의 경우, 하위 타입에서 프로퍼티를 오버라이드하면서 커스텀 접근자를 추가할 수 있기 때문에 스마트 캐스트를 할 수 없는 범주에 속한다.
    - 가변 지역 변수의 경우 검사하는 시점과 변수를 읽는 시점 사이에 값을 명시적으로 변경하거나 어떤 람다 안에서 변수를 변경하면 스마트 캐스트가 되지 않는다.
- 스마트 캐스트를 쓸 수 없는 경우에도 명시적인 연산자를 사용해 값의 타입을 강제로 변환할 수 있고 이 연산자로 as/as? 가 있다.
    - 실제 타입이 변환하려는 대상 타입과 일치하지 않을 경우 as는 예외를 던지고 as?는 null을 돌려준다.

### 8.1.4 공통 메서드

- 코틀린의 Any 클래스는 코틀린 클래스 계층 구조의 루트로 다른 모든 클래스가 Any를 직간접적으로 상속한다.
- Any 클래스에는 다음과 같은 연산을 하는 메서드들이 있다.
    - 구조적 동등성 (==와 !=)
    - 해시 코드 계산, HashSet, HashMap 들의 일부 컬렉션 타입이 해시 코드를 사용한다.
    - String으로 변환하는 기본적인 방법
- 코틀린에서 클래스들은 기본적으로 Any에서 상속받은 참조 동등성만 구현한다. 이를 equals() 메서드를 오버라이딩해서 동등성을 비교하는 방식으로 해결할 수 있다.
- equals() 구현의 일반적인 요구 사항은 자바와 같다.
    - 널이 아닌 객체가 널과 같을 수 없다.
    - 동등성 연산은 반사적이어야 한다. 즉, 모든 객체는 자기 자신과 동등해야 한다.
    - 동등성 연산은 대칭적이어야 한다. 즉 a == b이면 b == a여야 한다.
    - 동등성 연산은 추이적이어야 한다. 즉 a == b이고 b == c이면 a == c여야 한다.
  
## 8.2 추상 클래스와 인터페이스

- 별도의 인스턴스가 있을 수 없고, 구체적인 경우를 구현한 다른 클래스의 인스턴스만 만들 수 있는 추상적인 개념을 표현하는 클래스라면 인스턴스 생성은 바람직하지 않다.

### 8.2.1 추상 클래스와 추상 멤버

- 자바와 마찬가지로 코틀린도 추상 클래스를 지원한다. 추상 클래스는 직접 인스턴스화할 수 없고 다른 클래스의 상위 클래스 역할만 할 수 있는 클래스를 뜻한다. 클래스를 추상 클래스로 만들려면 `abstract` 라는 변경자 키워드를 붙여야 한다.
- 추상 클래스에도 생성자가 있을 수 있다. 추상 클래스와 비추상클래스의 차이는 추상 클래스의 생성자가 오직 하위 클래스의 생성자에서 위임 호출로만 호출될 수 있다는 점이다.
- 추상 클래스의 또 다른 특징은 추상 멤버를 정의할 수 있다는 것이다. 비추상 클래스가 추상적인 부모 클래스로부터 이런 멤버를 상속할 때는 반드시 멤버를 오버라이드 해서 구현을 제공해야 한다.
  - 추상 멤버는 타입, 파라미터, 반환 타입 등 함수나 프로퍼티의 기본적인 모습을 정의하지만 세부 구현을 생략한 멤버다.
- 추상 멤버 자체는 구현을 가질 수 없으므로 추상 멤버를 정의할 때는 몇 가지 제약이 있다.
  - 추상 프로퍼티를 초기화할 수 없고 명시적인 접근자나 by 절을 추가할 수 없다.
  - 추상 함수에는 본문이 없어야 한다.
  - 추상 프로퍼티와 함수 모두 명시적으로 반환 타입을 적어야 한다. 본문이나 초기화 코드가 없으므로 타입을 추론할 수 없기 때문이다.
- 추상 멤버는 암시적으로 열려 있어 open을 명시할 필요가 없다.

### 8.2.2 인터페이스

- 근본적으로 인터페이스는 메서드나 프로퍼티를 포함하지만 자체적인 인스턴스 상태나 생성자를 만들 수는 없는 타입이다.
- 인터페이스 멤버는 디폴트가 추상 멤버다. 따라서 구현을 제공하지 않으면 abstract 변경자가 자동으로 붙은 것처럼 간주된다.
- 인터페이스는 클래스나 다른 인터페이스의 상위 타입이 될 수 있다. 클래스가 인터페이스를 상속한 클래스에 있는 인터페이스 멤버를 상속해 구현할 때도 override 키워드를 추가해야 한다.
- 인터페이스를 상속할 때는 implements, 클래스를 상속할 때는 extends를 써야만 하는 자바와 달리 코틀린에서는 모든 상속을 : 를 사용해 표시한다.
- 인터페이스 안의 함수와 프로퍼티에 구현을 추가할 수 있고, 이런 구현은 암시적으로 열려 있는 것으로 간주된다.
- 인터페이스 멤버를 final로 정의하면 컴파일 오류가 발생한다. 하지만 확장 함수나 프로퍼티를 사용하면 final 멤버를 대신할 수 있다.
- 인터페이스를 인터페이스로 상속할 때도 메서드를 오버라이드 할 수 있다.
- 인터페이스 내부에 상태를 정의할 수 없으므로 인터페이스 안에는 뒷받침하는 필드가 들어있는 프로퍼티를 정의할 수 없다. 초기화 코드나 위임이 붙은 프로퍼티는 금지된다.
- 인터페이스는 암묵적으로 추상 타입이나, 추상 클래스와 달리 인터페이스에 대한 생성자는 금지돼 있다.
- 한 타입이 동일한 시그니처를 가지는 멤버가 들어있는 다른 인터페이스를 둘 이상 상속하는 경우 멤버들이 한 멤버로 합쳐지고 하위 타입은 이를 상속하는 것 같은 효과가 일어난다.

    ```kotlin
    interface Car {
    	fun move()
    }
    
    interface Ship {
    	fun move()
    }
    
    class Amphibia : Car, Ship {
    	override fun move() {
    		println("I'm moving")
    	}
    }
    ```

  - 위 코드에서 move()메서드는 추상 메서드다. 따라서 비추상 클래스인 Amphibia에서는 이 메서드를 구현해야 한다. 상위 타입의 메서드 중에 구현이 존재하는 경우라 할지라도, 컴파일러는 모호성을 해결하기 위해 반드시 메서드를 명시적으로 구현하도록 강제한다.

    ```kotlin
    interface Car {
    	fun move() {
    		println("I'm riding")
    	}
    }
    
    interface Ship {
    	fun move()
    }
    
    class Amphibia : Car, Ship {
    	override fun move() {
    		super.move() // Car에서 상속받는 메서드를 호출
    	}
    }
    
    fun main() {
    	Amphibia().move() // I'm riding
    }
    ```

  - 합쳐지는 멤버에 대한 구현이 둘 이상의 상위 타입에 존재하는 경우, super 호출 자체가 모호해진다. 이럴 때는 super를 상위 타입으로 한정시킨 키워드를 사용해야 한다.

    ```kotlin
    class Amphibia : Car, Ship {
    	override fun move() {
    		super<Car>.move()
    		super<Ship>.move()
    	}
    }
    
    ```


### 8.2.3 봉인된 클래스와 인터페이스

- 어떤 클래스를 sealed로 지정하면, 이 클래스를 상속하는 클래스는 내포된 클래스 또는 객체로 정의되거나 같은 파일 안에서 최상위 클래스로 정의돼야만 한다.
- 영역 밖에서 봉인된 클래스는 final 클래스와 동일한 효과를 지니며, 아무도 봉인된 클래스를 상속할 수 없다.
- 봉인된 클래스의 인스턴스를 만들 때는 봉인된 클래스의 하위 클래스 중 하나를 선택해 만들어야 한다.
- sealed 변경자를 인터페이스에 적용할 수 없다는 점에 유의해야 한다.
- 봉인된 클래스를 객체로 구현할 수도 있다.
  - 모든 직접적인 상속자가 객체인 경우 봉인된 클래스는 결과적으로 이넘 클래스처럼 동작한다.

### 8.2.4 위임

- 기존 클래스를 확장하거나 변경해야 하는데 이를 상속할 수 없다면 위임 패턴을 사용할 수 있다.
- 어떤 인터페이스의 구현을 만들고 싶다면 이미 있는 구현의 인스턴스를 가져와서 우리가 만드는 클래스로 감싸고, 필요할 때 인터페이스 메서드 구현을 이 기존 구현 인스턴스에 위임할 수 있다.
  - 구현 방법은 상위 인터페이스 이름 바로 뒤에 by 키워드를 붙이고 그 다음에 위임할 인스턴스를 작성하면 된다.
  - 구현을 바꾸고 싶으면 직접 멤버를 오버라이드할 수도 있다.
- 일반적으로 클래스 초기화 시 사용할 수 있는 대부분의 일을 위임으로 처리할 수 있다. 컴파일러는 위임된 값을 저장하는 필드를 자동으로 만들어준다.
- 클래스 본문에 정의된 프로퍼티를 클래스 위임에 사용할 수 없고, 인터페이스 멤버를 구현할 때만 위임을 사용할 수 있다.