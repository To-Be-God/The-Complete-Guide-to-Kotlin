# 08 클래스 계층 이해하기

## 8.1 상속

- 도메인 개념에 있는 is-a 관계를 표현하기 위해 대부분의 객체지향 언어는 상속이라는 개념을 사용한다.
- 자바와 마찬가지로 코틀린 클래스는 단일 상속만을 지원한다. 어떤 클래스의 상위 클래스를 명시하지 않으면 컴파일러는 자동으로 이 클래스가 내장 클래스인 Any를 상속하는 것으로 가정한다.

### 8.1.1 하위 클래스 선언

- 자바와 달리 코틀린에서는 `extends` 와 `implements` 와 같은 특별한 키워드 대신 `:` 으로 표시된다.
- `open` 키워드는 해당 클래스가 상속에 대해 열려 있다는 뜻이다. 즉, 해당 클래스를 상위 클래스로 지정할 수 있다는 것이다.
- 자바에서는 모든 클래스가 디폴트로 열려 있으며, 상속을 금지하려면 `final`을 명시해야 하는 반면, 코틀린에서는 디폴트가 final이다. 따라서 상속을 허용하려면 `open` 키워드가 필요하다.
- 또한 코틀린에서 멤버를 오버라이드하는 경우에는 `override` 키워드를 앞에 붙여야만 한다.
- 특정 클래스들은 상속을 제한적으로 지원한다.
    - 데이터 클래스는 항상 `final` 이며, `open` 으로 선언할 수 없다.
    - 인라인 클래스는 다른 클래스를 상속할 수도 없고, 다른 클래스의 상위 클래스 역할을 할 수도 없다.
- 상속이 제공하는 강력한 기능은 임의 다형성이다. 임의 다형성은 상위 클래스 멤버의 여러 다른 구현을 하위 클래스에서 제공하고 런타임에 실제 인스턴스가 속한 클래스에 따라 구현을 선택해주는 기능을 말한다.
    - 코틀린에서는 상위 클래스의 멤버를 오버라이드해서 임의 다형성을 달성할 수 있다.

    ```kotlin
    open class Vehicle {
      open fun start() {
        println("I'm moving")
      }
      fun stop() {
        println("Stopped")
      }
    }
    
    class Car: Vehicle() { 
       override fun start() {
         println("I'm riding")
       }
     }
    
    class Boat: Vehicle() {
      override fun start() {
        println("I'm sailing")
      }
    }
    ```

    - `Vehicele` 클래스는 `start()` 메서드의 공통 구현을 제공한다. 그리고 이를 상속한 클래스인 `Car` 와 `Boat` 는 `start()` 를 오버라이드한다.
    - `Vehicele` 타입에 대한 메서드 호출은 런타임에 그 인스턴스의 클래스가 무엇인지에 따라 달라진다.

        ```kotlin
        fun main() {
        	startAndStop(Car())
        	startAndStop(Boat())
        }
        ```

- 클래스 멤버는 `final` 이 아니라면 오버라이드할 수 있고 그에 따라 런타임에 인스턴스의 구체적인 타입에 따라 어떤 구현이 호출될지 결정할 수 있지만, 확장은 항상 정적으로 호출할 대상이 결정된다.

    ```kotlin
    open class Vehicle {
    	open fun start() {
    		println("I'm moving")
    	}
    }
    
    fun Vehicle.stop() {
    	println("Stopped moving")
    }
    
    class Car : Vehicle() {
     override fun start() {
       println("I'm riding")
     }
    }
    
    fun Car.stop() {
      println("Stopped riding")
    }
    
    fun main() {
    	val vehicle: Vehicle = Car()
    	vehicle.start() // I'm riding -> 클래스 멤버라 동적으로 결정이 가능 vehicle 변수의 런타임 타입
    	vehicle.stop() // stopped moving -> vehicle 변수의 정적 타입
    } 
     
    ```

- 오버라이드하는 멤버를 final로 선언하면 더 이상 하위 클래스가 이 멤버를 오버라이드할 수 없다.
- 불변 프로퍼티를 가변 프로퍼티로 오버라이드할 수 있다.
- 멤버의 영역을 하위 클래스의 영역으로만 제한하고 싶은 경우, `protected` 라는 키워드를 붙이면 된다.
- 함수나 프로퍼티를 오버라이드한 버전이 원래 버전을 재사용하고 싶은 경우 `super` 키워드를 붙이면 된다.

### 8.1.2 하위 클래스 초기화

- 하위 클래스의 인스턴스를 생성하는 동안에 프로그램은 상위 클래스에 정의된 초기화 코드를 호출해야 한다.
    - 상위 클래스에서 초기화하는 상태가 하위 클래스 코드가 사용할 환경이 되기 때문에 항상 상위 클래스 초기화를 먼저 시행해야 한다.
- 데이터를 상위 클래스 생성자에게 전달하는 방법은 상위 클래스에 생성자를 두거나, 자식 클래스에 부생성자를 두는 방법이 있다.
    - 부생성자를 사용하는 경우에는 `super` 키워드를 사용해야 한다.
- 자바와 달리 코틀린에서는 생성자 간의 호출이 생성자 본문에 들어가는 일이 결코 없기에 코틀린에서는 이를 위해 항상 위임 호출 구문을 사용해야 한다.
- 주생성자가 있으면 부생성자가 상위 클래스를 위임 호출할 수 없다.
- 상위 클래스가 여러 생성자를 제공하고 하위 클래스에서 상위 클래스의 생성자 중 둘 이상을 지원하고 싶을 때는 주 생성자를 선언하지 않고 부 생성자만 정의하면 된다.
- 상위 클래스를 초기화할 때 조심해야 할 부분은 this 누출 문제이다.
    - this 누출 문제는 하위 클래스가 초기화 되기 전에 상위 클래스에서 이미 정의된 메서드를 오버라이드하여 호출할 경우 예상하지 못한 결과가 반환되는 문제이다.
    - this 누출 문제는 코틀린에서 널이 될 수 없는 타입의 변수 값이 널이 될 수 있는 드문 경우이다.

### 8.1.3 타입 검사와 캐스팅

- 코틀린에서는 is 연산자를 통해서 타입 검사를 할 수 있다.
- is, !is 연산자의 왼쪽 피연산자의 정적 타입이 오른쪽에 오는 타입의 상위 타입인 경우에만 두 연산자를 사용할 수 있다.
- is 연산자와 instanceof 연산자는 매우 비슷하지만 instanceOf 연산자는 null에 대해 항상 false를 반환하지만,  is의 결과는 연산자 오른쪽에 있는 타입이 null이 될 수 있는지 여부에 따라 결과가 달라진다.
- is/!is 연산자를 사용하면 스마트 캐스트가 가능하다.
    - 컴파일러는 검사 시점과 사용 시점 사이에 변수가 변경되지 않는다고 확신할 때만 스마트 캐스트를 허용한다.
    - 먼저 프로퍼티나 커스텀 접근자가 정의된 변수에 대해서는 스마트 캐스트를 쓸 수 없다.
    - 열린 멤버 프로퍼티의 경우, 하위 타입에서 프로퍼티를 오버라이드하면서 커스텀 접근자를 추가할 수 있기 때문에 스마트 캐스트를 할 수 없는 범주에 속한다.
    - 가변 지역 변수의 경우 검사하는 시점과 변수를 읽는 시점 사이에 값을 명시적으로 변경하거나 어떤 람다 안에서 변수를 변경하면 스마트 캐스트가 되지 않는다.
- 스마트 캐스트를 쓸 수 없는 경우에도 명시적인 연산자를 사용해 값의 타입을 강제로 변환할 수 있고 이 연산자로 as/as? 가 있다.
    - 실제 타입이 변환하려는 대상 타입과 일치하지 않을 경우 as는 예외를 던지고 as?는 null을 돌려준다.

### 8.1.4 공통 메서드

- 코틀린의 Any 클래스는 코틀린 클래스 계층 구조의 루트로 다른 모든 클래스가 Any를 직간접적으로 상속한다.
- Any 클래스에는 다음과 같은 연산을 하는 메서드들이 있다.
    - 구조적 동등성 (==와 !=)
    - 해시 코드 계산, HashSet, HashMap 들의 일부 컬렉션 타입이 해시 코드를 사용한다.
    - String으로 변환하는 기본적인 방법
- 코틀린에서 클래스들은 기본적으로 Any에서 상속받은 참조 동등성만 구현한다. 이를 equals() 메서드를 오버라이딩해서 동등성을 비교하는 방식으로 해결할 수 있다.
- equals() 구현의 일반적인 요구 사항은 자바와 같다.
    - 널이 아닌 객체가 널과 같을 수 없다.
    - 동등성 연산은 반사적이어야 한다. 즉, 모든 객체는 자기 자신과 동등해야 한다.
    - 동등성 연산은 대칭적이어야 한다. 즉 a == b이면 b == a여야 한다.
    - 동등성 연산은 추이적이어야 한다. 즉 a == b이고 b == c이면 a == c여야 한다.