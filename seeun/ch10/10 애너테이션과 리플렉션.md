# 10 애너테이션과 리플렉션

## 10.1 애너테이션

- 애너테이션은 커스텀 메타데이터를 정의하고 이 메타데이터를 소스코드상의 선언, 식, 전체 파일 등의 요소에 엮는 방법을 제공한다.
- 자바 애너테이션과 마찬가지로 코틀린 애너테이션도 런타임에 접근할 수 있다.

### 10.1.1 애너테이션 클래스 정의하고 사용하기

- 애너테이션의 가장 기본적인 사용 방법은 어떤 선언의 앞쪽에 변경자 위치에 @이 붙은 애너테이션 이름을 놓는 것이다.
- 자바와 달리 코틀린 애너테이션을 식에 적용할 수도 있다. 또한 같은 구성 요소에 애너테이션을 여럿 붙이고 싶다면 각괄호로([]) 애너테이션들을 감쌀 수 있다.

    ```kotlin
    @[Synchronized Strictfp] // @Synchronized @Strictfp와 같은 역할
    ```

- 애너테이션을 주생성자에 적용하고 싶을 때는 명시적으로 주생성자의 인자 목록 앞에 constructor 키워드를 붙여야 한다.

    ```kotlin
    class A @MyAnnotation constructor()
    ```

- 애너테이션을 정의하려면 클래스 앞에 annotation이라는 변경자를 붙여야 한다.
- 자바의 애너테이션은 인터페이스로 구성되지만, 코틀린 애너테이션은 특별한 종류의 클래스로 구성된다.
- 일반 클래스와 달리 애너테이션 클래스에는 멤버나 부생성자, 초기화 코드가 없다.
    - 코틀린 1.3 부터는 내포된 클래스, 인터페이스, 객체를 애너테이션 본문에 넣을 수 있다.
- 애너테이션에 커스텀 애트리뷰트를 추가하고 싶다면 생성자 파라미터를 통해야만 한다. 이와 같은 애너테이션을 사용할 때는 클래스 생성자를 호출할 때처럼 파라미터에 실제 인자를 제공해야 한다.

    ```kotlin
    annotation class MyAnnotation(val text: String) 
    
    @MyAnnotation("Some useful info") fun annotatedFun() {}
    ```

- 애너테이션 파라미터를 항상 val로 선언해야 한다는 점에 유의해라
- 일반적인 생성자와 마찬가지로 디폴트 값이나 가변 인자를 사용할 수도 있다.
- 코틀린 애너테이션은 클래스의 일종이지만, 일반 클래스처럼 인스턴스를 만들 수는 없다.
- 애너테이션 클래스에는 상위 타입을 명시할 수도, 애너테이션 클래스를 상속하는 클래스를 정의 할 수도 없다.
- 애너테이션은 Any 클래스와 빈 Annotation 인터페이스를 자동으로 상속하며, 이 둘은 모든 애너테이션 클래스의 공통 상위 타입 역할을 한다.
- 애너테이션 인자는 컴파일 시에만 평가되므로 애너테이션 인자에 임의의 식을 넣을 수는 없다. 더 나아가 컴파일러는 애너테이션 파라미터로 사용할 수 있는 타입의 종류를 다음과 같이 제한한다.
    - Int, Boolean, Double : 원시 타입
    - String
    - Enum
    - 다른 애너테이션
    - 클래스 리터럴
    - 위 타입들로 이뤄진 배열
    - JVM에서는 애너테이션 애트리뷰트에 널을 저장할 수 없으므로 이와 같은 파라미터는 널이 될 수 없다.
- 다른 애너테이션을 인자로 사용하는 경우에는 @ 접두사를 안 붙여도 된다. 대신 일반 생성자 호출처럼 애너테이션을 사용하면 된다.
- 애너테이션 파라미터로 명시적인 배열 타입을 사용할 수 있다.

    ```kotlin
    annotation class Dependency(val componentNames: Array<String>)
    
    @Component(dependency = Dependency(arrayOf..)
    ```

    - 코틀린 1.2부터는 애너테이션 인자로 각괄호([])를 사용해 더 간결하게 배열을 만들 수 있다.
    - 각괄호를 사용한 배열 표현의 경우 현재는 애너테이션에서만 사용할 수 있다.
- 클래스 리터럴을 사용하면 kClass 타입의 리플랙션 객체로 클래스에 대한 표현을 얻을 수 있다.
    - 이 kClass 타입은 자바 언어의 Class 타입에 해당하는 코틀린 클래스로, 클래스 이름 뒤에 ::class를 붙여서 클래스 리터럴을 만든다.

    ```kotlin
    annotation class Dependency(vararg val componentClasses: kClass<*>)
    ..
    @Component("Long, Dependency(IO:class))
    ```

- 코틀린 소스코드에서 여러 언어 요소가 함축돼 있는 선언에 대해 애너테이션이 붙을 수도 있다.

    ```kotlin
    class Person(val name: String)
    ```

    - val name: String은 생성자 파라미터와 게터가 있는 클래스 프로퍼티, 그리고 프로퍼티 값을 저장하기 위한 뒷받침하는 필드 선언을 짧게 줄인 코드이다.
    - 이런 요소 각각에 대해 애너테이션을 붙일 수 있으므로 코틀린에서는 애너테이션을 사용하는 시점에 어떤 대상에 대해 애너테이션을 붙이는지 지정할 수 있다.

  **키워드 종류**

  > property: 프로퍼티 자체를 대상으로 한다.
  >

  > field: 뒷받침하는 필드를 대상으로 한다.
  >

  > get: 프로퍼티 게터를 대상으로 한다.
  >

  > set: 프로퍼티 세터를 대상으로 한다.
  >

  > param: 생성자 파라미터를 대상으로 한다.
  >

  > setparam: 프로퍼티 세터의 파라미터를 대상으로 한다.
  >

  > delegate: 위침 객체를 저장하는 필드를 대상으로 한다.
  >

  > receiver: 확장 함수나 프로퍼티의 수신 객체를 대상으로 한다.
  >

  > file: 전체 파일을 대상으로 한다.
>
- 사용 지점 대상을 사용하는 애너테이션을 [] 구문으로 묶을 수 있다.

### 10.1.2 내장 애너테이션

- 내장 애너테이션 중 일부는 애너테이션 클래스 자체에 적용 가능하며, 이런 애너테이션을 통해 대상 애너테이션의 사용 방법을 바꿀 수 있다.

**@Retention**

- 애너테이션이 저장되고 유지되는 방식을 제어
- SOURCE: 컴파일 시점에만 존재하며 컴파일러의 바이너리 출력에는 저장되지 않는다.
- BINARY: 컴파일러의 바이너리 출력에 저장되지만, 런타임에 리플렉션 API로 관찰할 수는 없다.
- RUNTIME: 컴파일러의 바이너리 출력에 저장되며 런타임에 리플렉션 API를 통해 관찰할 수도 있다.
- 디폴트로 코틀린 애너테이션은 RUNTIME으로 유지 시점이 정의된다. 따라서 리플렉션 API에서 코틀린 애너테이션을 찾지 못하는 일은 발생하지 않는다.
- 하지만 식에 대해 붙은 애너테이션의 경우 런타임까지 유지되지 못하여 식에 붙는 애너테이션에 대해 BINARY나 RUNTIME을 지정하는 것은 금지돼 있다.
    - 이런 경우에는 명시적으로 SOURCE 유지 시점을 지정해야 한다.
- 자바와 코틀린의 디폴트 유지 시점 차이를 기억하라. 자바에서는 디폴트가 BINARY이며, 이는 명시적으로 RUNTIME으로 지정하지 않으면 자바 애너테이션을 리플렉션에서 관찰할 수 없다는 것을 의미한다.
- 기본적으로 애너테이션을 반복 적용할 수는 없으나 @Repeatable아 붙은 애너테이션은 같은 언어 요소에 두 번 이상 반복 적용할 수 있다.
- 현재는 반복할 수 있는 애너테이션을 런타임까지 유지할 수 없기 때문에 반복할 수 있는 애너테이션의 유지 시점을 반드시 SOURCE로 명시해야 한다.

**@MustBeDocumented**

- 애너테이션을 문서에 꼭 포함시키라는 뜻이다. 애너테이션도 공개 API인 경우 이 애너테이션을 붙인다.

**@Target**

- 애너테이션을 어떤 언어 요소에 붙일 수 있는지 지정한다.
    - CLASS: 클래스, 인터페이스, 객체에 붙일 수 있다.
    - ANNOTATION_CLASS: 애너테이션 클래스에 붙일 수 있다.
    - TYPEALIAS: 타입 별명 정의에 붙일 수 있다
    - PROPERTY: 주생성자에 정의딘 val/var 프로퍼티를 포함해 프로퍼티에 붙일 수 있다(지역 변수 불가)
    - FIELD: 프로퍼티 뒷받침 필드에 붙일 수 있다
    - LOCAL_VARIABLE: 지역 변수에 붙일 수 있다
    - VALUE_PARAMETER: 생성자, 함수, 프로퍼티 세터의 파라미터에 붙일 수 있다
    - CONSTRUCTOR: 주생성자, 부생성자에 붙일 수 있다
    - FUNCTION: 람다나 익명 함수를 포함해 함수에 붙일 수 있다(생성자, 프로퍼티 접근자는 불가)
    - PROPERTY_GETTER/SETTER: 프로퍼티 게터/세터에 붙일 수 있다
    - FILE: 파일에 붙일 수 있다
    - TYPE: 타입 지정 변수 타입이나 파라미터 타입, 반환 타입 등을 포함한다.
    - EXPRESSION: 식에 붙일 수 있다
- 해당 애너테이션을 지정하지 않으면 타입 별명, 파라미터, 지정, 식 파일을 제외한 언어 요소에 적용할 수 있다.
- 다음 애너테이션은 이름이 같은 자바 변경자와 같은 역할을 한다.
    - @StrictFp: 부동소수점 연산 정밀도 제한한다.
    - @Synchronized: 애너테이션이 붙은 함수나 프로퍼티 접근자의 본문에 진입하기 전에 모니터 획득 후 본문을 수행한다.
    - @Volatile: 뒷받침 필드를 변경한 내용을 즉시 다른 스레드에서 즉시 관찰할 수 있게 해준다.
    - @Transient: 애너테이션이 붙은 필드를 직렬화 메커니즘이 무시한다.

**@Suppress**

- 지정한 이름의 컴파일러 경고를 표시하지 않게 할 수 있다.
- 자신이 적용된 요소 내부에 있는 모든 코드에 적용된다.

**@Deprecated**

- 사용 금지 예정 선언을 통해 클라이언트 코드에게 해당 선언을 사용하지 않는 것을 권장하게 한다.
- 코틀린에서는 추가적으로 사용 금지 예정인 선언을 사용하는 코드에서 사용 금지된 식을 다른 식으로 변경할 수 있게 해준다.
- 또한 사용 금지 예정의 심각성을 지정할 수 있다.
    - WARNING : 경고 표시한다. (디폴트 동작)
    - ERROR : 컴파일 오류로 처리한다.
    - HIDDEN : 아예 접근하지 못하게 막는다.