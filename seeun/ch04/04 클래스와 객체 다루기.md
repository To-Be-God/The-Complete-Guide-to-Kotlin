# 04 클래스와 객체 다루기

## 4.1 클래스 정의하기

- 기본적으로 클래스 선언은 참조 타입을 정의한다. 즉, 이런 참조 타입의 값은 특정 클래스 인스턴스의 실제 데이터 위치를 가리키는 참조다.

### 클래스 내부 구조

- 자바와 마찬가지로 코틀린 클래스도 class 키워드 다음에 클래스 이름이 오고 그 다음에 클래스 본문이 오늘 형태로 정의된다.

    ```kotlin
    class Person {
    	var firstName: String = ""
    	var familyName: String = ""
    	var age: Int = 0
    	
    	fun fullName() = "$firstName &familyName"
    	
    	fun showMe() {
    		println("${fullName()}: $age")
    	}
    }
    ```

- 위에 코드는 Person 클래스의 인스턴스마다 firstName, familyName, age라는 프로퍼티와 fullName() 및 showMe()라는 두 함수가 들어있음을 알려준다.
- 여러 가지 프로퍼티 유형 중 가장 단순한 것은 그냥 특정 클래스와 연관된 변수다. 자바 클래스 필드와 비슷하게 생각될 수도 있으며, 더 일반적인 경우에는 프로퍼티에 어떤 계산이 포함될 수 있다.
    - 이런 경우에는 클래스 인스턴스 내부에 저장되는 대신 그때그때 계산되거나 지연 계산되거나 맵에서 값을 얻어오는 등의 방식으로 프로퍼티의 값을 제공할 수 있다.
- 모든 프로퍼티에서 일반적으로 쓸 수 있는 기능에는 다음과 같이 변수처럼 프로퍼티를 사용하는 참조 구문이 있다.

    ```kotlin
    fun showAge(p: Person) = println(p.age) // 프로퍼티 읽기
    fun readAge(p: Person) {
    	p.age = readLine()!!.toInt() // 프로퍼티 쓰기
    }
    ```

- 프로퍼티는 어떤 클래스의 구체적인 인스턴스와 엮여 있기 때문에 이 인스턴스를 식으로 지정해야 한다. (위에 코드에서는 p)
- 이런 인스턴스를 수신 객체라고 부르고, 수신 객체는 프로퍼티에 접근할 때 사용해야 하는 객체를 지정한다. 멤버 함수의 경우에도 똑같이 수신 객체가 있고, 이런 경우 멤버 함수를 메서드라 부른다.

    ```kotlin
    fun showFullName(p: Person) = println(p.fullname())
    ```

- 수신 객체를 모든 클래스 멤버에게 암시적으로 제공되는 사용 가능한 추가 변수라고 생각해도 된다. 클래스 내부에서는 this 식으로 수신 객체를 참조할 수 있다. 대부분의 경우 this를 디폴트로 가정하기 때문에 수신 객체 안에서 참조할 때는 this를 생략해도 된다.
    - 하지만 때로는 this가 꼭 필요한 경우도 있다. 예를 들어 어떤 클래스의 프로터피와 메서드 파라미터 이름이 같은 경우, 이 둘을 구분하기 위해 프로퍼티 이름 앞에 this를 써야한다.
- 자바와 달리 코틀린에서는 클라이언트 코드를 바꾸지 않아도 원하는 대로 프로퍼티 구현을 바꿀 수 있기 때문에 코틀린 프로퍼티는 캡슐화에 위배되지 않는다.
    - https://colabear754.tistory.com/164
- 프로퍼티가 사용하는 내부 필드는 항상 캡슐화돼 있고 클래스 정의 밖에서는 이 내부 필드에 접근할 수 없다.
- 클래스 인스턴스의 프로퍼티나 메서드를 사용하려면 인스턴스를 명시적으로 생성해야 한다.

    ```kotlin
    fun main() {
    	val person = Person()
    	
    	person.firstName = "John"
    	person.familyName = "Doe"
    	person.age = 25
    	
    	person.showMe() 
    }
    ```

- 생성자 호출을 사용하면 프로그램이 새 인스턴스에 대한 힙 메모리를 할당한 다음, 인스턴스의 상태를 초기화해주는 생성자 코드를 호출해준다.
- 기본적으로 코틀린 클래스는 Public이다. internal이나 private으로 설정할 수 있다.
    - 자바에서는 코틀린과 다르게 기본적인 가시성이 클래스가 포함된 패키지 내부로 제한된다 (package private) 자바에서 어떤 정의를 어느 곳에서나 쓸 수 있게 하려면 명시적으로 public 변경자를 붙어야한다.
- 클래스 프로퍼티는 지역 변수와 마찬가지로 불변일 수 있다. 이런 경우 초기화를 하는 동안 프로퍼티의 값을 지정할 수단이 있어야 하는데, 이를 해결해 주는 것이 커스텀 생성자이다.

### 생성자

- 생성자는 클래스 인스턴스를 초기화해주고 인스턴스 생성 시 호출되는 특별한 함수다.

    ```kotlin
    class Person(firstName: String, familyName: String) {
    	val fullName = "$firstName $familyName"
    }
    ```

- class 키워드 이름 뒤에 덧붙인 파라미터는 프로그램이 클래스의 인스턴스를 생성할 때 클래스에 전달된다. 이 파라미터를 사용해 프로퍼티를 초기화하고 다른 일을 수행할 수 있다.

    ```kotlin
    fun main() {
    	val person = Person("John", "Doe") // 새 Person 인스턴스 생성
    	println(person.fullName) // John Doe
    }
    ```

- 코틀린에서는 생성자를 호출할 때 자바의 new와 같은 특별한 키워드를 사용하지 않는다.
- 클래스 헤더의 파라미터 목록을 주생성자(primary constructor) 선언이라고 한다. 주생성자는 함수와 달리 본문이 하나가 아니다.
- 대신 주생성자는 클래스 정의 내에서 프로퍼티 초기화와 초기화 블록(init이라는 키워드가 붙은 블록)이 등장하는 순서대로 구성된다.
    - 초기화 블록에는 return 문이 들어가지 못한다.
    - 프로퍼티 값을 프로퍼티 정의 시 초기화 하는 방법이 일반적이지만, 하나의 식으로 표현하기 어려운 복잡한 초기화 로직을 실행해야 프로퍼티를 초기화할 수 있는 경우도 있다.
    - 이런 이유로 코틀린은 init 블록 안에서 프로퍼티를 초기화하는 것도 허용한다.

    ```kotlin
    class Person(fullName: String) {
      val firstName: String
      val familyName: String
      init {
        val names = fullName.split(" ")
        if (names.size != 2) {
          throw IllegalArgumentException("Invalid name: $fullName")
        }
        firstName = names[0]
        familyName = names[1]
      }
    }
    
    fun main() {
      val person = Person("John Doe")
      println(person.firstName) // John
    }
    ```

    - 위에 코드를 보면 init 블록 안에서 firstName과 familyName 프로퍼티를 초기화한다.
- 컴파일러는 모든 프로퍼티가 확실히 초기화되는지 확인한다. 컴파일러가 주생성자의 모든 실행 경로가 모든 멤버 프로퍼티를 초기화하거나 예외를 발생시키는지 확인할 수 없다면 오류를 발생시킨다.
- 주생성자 파라미터를 프로퍼티 초기화나 init 블록 밖에서 사용할 수는 없다.
    - 이를 해결하기 위해서는 생성자 파라미터 값을 저장할 멤버 프로퍼티를 정의하면 된다.

    ```kotlin
    class Person(firstName: String, familyName: String) {
      val firstName = firstName // firstName은 생성자 파라미터를 가리킴
      val fullName = "$firstName $familyName"
      fun printFirstName() {
        println(firstName) // 여기서 firstName은 멤버 프로퍼티를 가리킴
      }
    }
    ```

    - 코틀린은 간단하게 생성자 파라미터 값을 멤버 프로퍼티로 만들 수 있는 방법을 제공한다.

    ```kotlin
    class Person(val firstName: String, familyName: String) {
      // firstName은 생성자 파라미터를 가리킴
      val fullName = "$firstName $familyName"
      
      fun printFirstName() {
        println(firstName) // firstName은 멤버 프로퍼티를 가리킴
      }
    }
    
    fun main() {
      val person = Person("John", "Doe")
      println(person.firstName) // firstName은 프로퍼티를 가리킴
    }
    ```

    - 기본적으로 생성자 파라미터 앞에 val이나 var 키워드를 덧붙이면 자동으로 해당 생성자 파라미터로 초기화되는 프로퍼티를 정의한다.
    - 이때 파라미터 이름을 프로퍼티 초기화나 init 블록 안에서 참조하면 생성자 파라미터를 가리키고, 다른 위치에서 참조하면 프로퍼티를 가리키게 된다.
    - val/var 파라미터를 사용하면 프로퍼티 정의를 해주기 때문에 아래와 같은 본문이 비어있는 클래스를 정의할 수 있다.

        ```kotlin
        class Person(val firstName: String, val familyName: String = " ") {
        }
        ```

- 함수와 마찬가지로 디폴트 값과 vararg를 생성자 파라미터에 사용할 수 있다.
- 여러 생성자를 사용해 클래스 인스턴스를 서로 다른 방법으로 초기화 하고 싶은 경우 부생성자(secondary constructor)를 사용해 해결할 수 있다. 부생성자 문법은 함수 이름 대신에 constructor 키워드를 사용한다는 점을 제외하면 함수 정의 문법과 비슷하다.

    ```kotlin
    class Person {
      val firstName: String
      val familyName: String
      
      constructor(firstName: String, familyName: String) {
        this.firstName = firstName
        this.familyName = familyName
      }
      
      constructor(fullName: String) {
        val names = fullName.split(" ")
        if (names.size != 2) {
          throw IllegalArgumentException("Invalid name: $fullName")
        }
        firstName = names[0]
        familyName = names[1]
      }
    }
    ```

- 부생성자에 반환타입을 지정할 수는 없지만, 기본적으로 부생성자는 Unit 타입 값을 반환하는 함수와 마찬가지 형태이다.
- 클래스에 주생성자를 선언하지 않은 경우, 모든 부생성자는 자신의 본문을 실행하기 전에 프로퍼티 초기화와 init 블록을 실행한다.
- 다른 방법으로는 부생성자가 생성자 위임 호출을 사용해 다른 부생성자를 호출하는 것이 있다.

    ```kotlin
    class Person {
      val fullName: String
      constructor(firstName: String, familyName: String):
        this("$firstName $familyName") // firstName과 familyName을 받아서
      constructor(fullName: String) {
        this.fullName = fullName // fullName을 초기화 
      }
    }
    ```

- 클래스에 주생성자가 있다면 모든 부생성자는 주생성자에게 위임을 하거나 다른 부생성자에게 위임을 해야 한다.
- 부생성자의 파라미터 목록에는 val/var 키워드를 쓸 수 없다는 점에 유의하자.

### 멤버 가시성

- 가시성은 클래스 멤버마다 다르게 지정할 수 있다. 가시성을 사용해 구현과 관련한 세부 사항을 캡슐화함으로써 외부 코드로부터 구현 세부 사항을 격리시킬 수 있다.
    - public(공개): 멤버를 어디서나 볼 수 있다. 디폴트 가시성이 바로 public이다. 따라서 명시적으로 public을 표기할 필요가 없다.
    - internal(모듈 내부): 멤버를 멤버가 속한 클래스가 포함된 컴파일 모듈 내부에서만 볼 수 있다.
    - protected(보호): 멤버를 멤버가 속한 클래스와 멤버가 속한 클래스의 모든 하위 클래스 안에서 볼 수 있다.
    - private(비공개): 멤버를 멤버가 속한 클래스 내부에서만 볼 수 있다.
- 코틀린은 함수와 프로퍼티, 주생성자, 부생성자에 대한 가시성 변경자를 지원한다. 함수와 프로퍼티, 주생성자/부생성자는 모두 클래스 본문에 정의되거나 주생성자 파라미터로 정의된다. 주생성자의 가시성을 지정하려면 constructor 키워드를 꼭 명시해야 한다.

### 내포된 클래스

- 함수, 프로퍼티, 생성자 외에 코틀린 클래스는 다른 클래스도 멤버로 가질 수 있다. 이런 클래스를 내포된 클래스(nestes class)라고 부른다.

    ```kotlin
    class Person (val id: Id, val age: Int) {
      class Id(val firstName: String, val familyName: String)
      fun showMe() = println("${id.firstName} ${id.familyName}, $age")
    }
    
    fun main() {
      val id = Person.Id("John", "Doe")
      val person = Person(id, 25)
      person.showMe()
    }
    ```

- 내포된 클래스를 둘러싸고 있는 클래스의 본문 밖에서는 `Person.Id` 처럼 내포된 클래스 이름 앞에 바깥쪽 클래스의 이름을 덧붙여야만 내포된 클래스를 참조할 수 있다.
- 내포된 클래스에도 여러 가지 가시성을 지정할 수 있다.
- 내포된 클래스에 inner를 붙이면 자신을 둘러싼 외부 클래스의 현재 인스턴스에 접근할 수 있다.

    ```kotlin
    class Person(val firstName: String, val familyName: String) {
      inner class Possession(val description: String) {
        fun showOwner() = println(fullName())
      }
      private fun fullName() = "$firstName $familyName"
    }
    
    fun main() {
      val person = Person("John", "Doe")
      // Possession 생성자 호출
      val wallet = person.Possession("Wallet")
      wallet.showOwner() // John Doe
    }
    ```

- 일반적으로 this는 가장 내부의 클래스 인스턴스를 가리킨다. 따라서 내부 클래스 본문에서 this는 내부 클래스 자신을 가리킨다. 내부 클래스 본문에서 외부 클래스 인스턴스를 가리켜야 한다면 한정시킨 this식을 사용해야 한다.

### 지역 클래스

- 자바처럼 코틀린에서도 함수 본문에서 클래스를 정의할 수 있다. 이런 지역 클래스는 자신을 둘러싼 코드 블록 안에서만 쓰일 수 있다.
- 지역 함수와 비슷하게 코틀린 지역 클래스도 자신을 둘러싼 코드의 선언에 접근할 수 있다. 특히 지역 클래스는 클래스 본문 안에서 자신이 접근할 수 있는 값을 포획할 수 있고, 변경할 수 있다.
    - 코틀린과 달리 자바에서는 변수의 값을 변경할 수 없다.
    - 코틀린이 제공하는 포획 변수를 변경하는 기능은 그에 따른 비용을 수반한다.
    - 익명 객체와 이 객체를 둘러싸고 있는 코드 사이에 변수를 공유하기 위해 코틀린 컴파일러는 값을 특별한 래퍼 객체로 둘러싼다.
- 내포된 클래스와 달리 지역 클래스에는 가시성 변경자를 붙일 수 없다. 지역 클래스의 영역은 항상 자신을 둘러싼 블록으로 제한된다. 지역 클래스도 함수, 프로퍼티, 생성자, 내포된 클래스등 다른 클래스가 포함할 수 있는 모든 멤버를 포함할 수 있다. 내포된 클래스는 반드시 inner 클래스여야만 한다.

## 4.2 널 가능성

### 널이 될 수 있는 타입

- 자바와 달리 코틀린에서 기본적으로 모든 참조 타입을 널이 될 수 없는 타입이다.
- 따라서 함수 자체에서는 널에 대한 검사를 추가로 수행할 필요가 없고 파라미터를 역참조 할 때 NPE 발생을 걱정할 필요가 없다. 코틀린 컴파일러는 이런 오류를 컴파일 시점이 방지해준다.
- 코틀린에서 널이 될 수도 있는 값을 받는 함수를 작성하려면 파라미터 타입 뒤에 물음표(?)를 붙여서 타입을 널이 될 수 있는 타입으로 지정해야 한다.
- 코틀린에서 String? 같은 타입은 널이 될 수 있는 타입이라고 불린다. 모든 널이 될 수 있는 타입은 원래 타입의 상위 타입이며, 원래 타입에 속하는 모든 값으로 이뤄진 집합을 null로 확장한 집합이 값의 집합이 된다.
- 런타임에 널이 될 수 없는 값을 실제로 널이 될 수 있는 값과 차이가 없다. 둘 사이 구분을 컴파일 수준에서만 존재한다. 코틀린 컴파일러는 널이 될 수 없는 값을 표현하기 위해 어떤 래퍼(자바의 Optional과 같은)도 사용하지 않는다.
- 원시 타입도 널이 될 수 있는 타입이 존재한다. 하지만 원시 타입의 널이 될 수 있는 타입은 항상 박싱한 값만 표현한다.
- 가장 작은 널이 될 수 있는 타입은 Nothing?이다. 이 타입은 널 상수 이외의 어떤 값도 포함하지 않는다. 이 타입은 null 값 자체의 타입이며 다른 모든 널이 될 수 있는 타입의 하위 타입이다.
- 가장 큰 널이 될 수 있는 타입은 Any? 이다. Any?는 코틀린 타입 시스템 전체에서 가장 큰 타입으로, 널이 될 수 있는 모든 타입과 널이 될 수 없는 모든 타입의 상위 타입이다.
- 널이 될 수 있는 타입은 원래 타입에 들어있는 어떤 프로퍼티나 메서드도 제공하지 않는다. 멤버 함수를 호출하거나 프로퍼티를 읽는 등의 일반적인 연산이 null에서는 의미가 없기 때문이다. (코틀린의 확장 메커니즘을 활용해 자체적인 메서드와 프로퍼티를 제공한다)

### 널 가능성과 스마트 캐스트

- null에 대한 동등성 검사를 수행하면, 컴파일러는 코드 흐름의 한쪽에서는 대상 값이 null이고 다른 쪽에서는 null이 아님을 알 수 있다. 그 후 컴파일러는 이 정보를 사용해 값 타입을 세분화함으로써 널이 될 수 있는 타입을 널이 될 수 없는 값으로 타입 변환한다. 이런 기능을 스마트 캐스트라고 한다.

    ```kotlin
    fun isLetterString(s: String?): Boolean {
      if (s == null) return false
      
      // s는 여기서 널이 될 수 없다
      if (s.isEmpty()) return false
      
      for (ch in s) {
        if (!ch.isLetter()) return false
      }
      
      return true
    }
    ```

    - 위에 코드에서 컴파일러는 s == null이 참인 경우 return 문으로 끝나기 때문에 s == null을 비교하는 비교문 다음의 문장을 s가 null일 경우 결코 실행되지 않는다는 사실을 알 수 있다. 그 결과 s를 null이 될 수 없는 String 타입으로 가정하고 나머지 함수 본문을 실행한다.
- 스마트 캐스트는 when이나 루프 같은 조건 검사가 들어가는 다른 문이나 식 안에서도 작동한다.
- 스마트 캐스트를 실행하려면 대상 변수의 값이 검사 지점과 사용 지점 사이에서 변하지 않는다고 컴파일러가 확신할 수 있어야 한다.
    - 불변 지역 변수는 초기화 후 변경되지 않으므로 항상 스마트 캐스트를 쓸 수 있지만 null 검사와 사용 지점 사이에서 값이 변경되는 경우에는 스마트 캐스트가 작동하지 않는다
    - 따라서 가변 프로퍼티에 대해서는 절대 스마트 캐스트를 적용할 수 없다. 언제든 코드의 다른 부분에서 프로퍼티 값을 바꿀 수 있기 때문이다.

### 널 아님 단언 연산자

- !! 연산자는 널 아님 단언이라고도 부르는데, NPE를 발생시킬 수 있는 연산자이다.
- 이 연산자가 붙은 식의 타입은 원래 타입의 널이 될 수 없는 버전이다.
- 일반적으로 널이 될 수 있는 값을 사용하려면 그냥 예외를 던지는 방식보다 더 타당한 응답을 제공해야 하기 떄문에 이 연산자를 사용하지 말아야 한다.
- 다른 후위 연산자와 마찬가지로 널 아님 단언 연산자도 가장 높은 우선순위로 취급된다.

### 안전한 호출 연산자

- 널이 될 수 있는 타입의 값에 대해서는 그에 상응하는 널이 될 수 없는 타입의 값에 있는 메서드를 사용할 수 없다. 하지만 특별한 호출 연산을 사용하면 이런 제약을 피할 수 있다.

    ```kotlin
    fun readInt() = readLine()?.toInt() 
    
    fun readInt(): Int? {
    	val tmp = readLine()
    	
    	return if(tmp != null) tmp.toInt() else null
    }
    ```

- 안전한 호출 연산자는 수식 객체가 null이 아닌 경우 일반적인 함수 호출처럼 작동한다. 하지만 수신 객체가 null이면 안전한 호출 연산자는 호출을 수행하지 않고 그냥 null을 반환한다.
- 안전한 호출 연산도 지연 연산의 의미를 따른다. 따라서 수신 객체가 null이면 함수의 인자를 계산하지 않는다.

### 엘비스 연산자

- 널이 될 수 있는 값을 다룰 때 유용한 연산자로 널 복합 연산자인 ?: 을 들 수 있다. 이 연산자를 사용하면 널을 대신할 디폴트 값을 지정할 수 있다.
- return이나 throw 같은 제어 흐름을 깨는 코드를 if 식을 대신하여 엘비스 연산자 오른쪽에 넣는 방법도 있다.