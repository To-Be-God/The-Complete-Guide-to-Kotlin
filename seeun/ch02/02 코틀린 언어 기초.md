# 02 코틀린 언어 기초

## 2.1 기본 문법

### 변수 정의하기

- 코틀린에서 변수를 정의하는 가장 간단한 형태는 다음과 같다.
    
    ```kotlin
    val timeInSeconds = 15
    ```
    
- 이 코드를 이루는 요소들은 다음과 같다.
    - val 키워드 : 값을 뜻하는 value에서 유래했다.
    - 변수 식별자 : 새 변수에 이름을 부여하고, 나중에 이를 가리킬 때 사용한다.
    - 변수의 초깃값을 정의하는 식 : = 기호 뒤에 온다
- 코틀린에서는 줄 끝에 세미콜론을 생략해도 된다. (실제로 이를 더 권장한다)

- 사용자에게 정수 두 개를 물어보고 그 두 수의 합을 표시하는 프로그램
    
    ```kotlin
    fun main() {
    	val a = readLine()!!.toInt()
    	val b = readLine()!!.toInt()
    	println(a+b)
    }
    ```
    
    - readLine은 표준 입력에서 한 줄을 읽어서 문자열로 반환해주는 표준 코틀린 함수이다.
    - !! 은 not-null assertion으로 readLine()의 결과가 null인 경우 예외를 발생시킨다.
        - 코틀린은 어떤 타입이 널 값이 될 수 있는지를 추적하고, 널이 아닌 것이 확실하지 않은 값에 대해 함수를 호출하지 못하게 막음으로써 널로 인한 오류를 방지한다.
        - 널을 반환하지 않을 것이라 확신하는 경우 !! 을 사용한다.
    - toInt()는 메서드가 호출된 대상 문자열을 정숫값으로 변환한다. 대상 문자열이 올바른 정숫값의 형태가 아니라면 toInt()는 런타임 오류를 내면서 프로그램을 종료시킨다.
    - println()은 인자로 받은 값을 표준 출력에 출력한다.
- 위에 코드를 보면 알 수 있지만, 변수 타입을 지정하지 않아도 프로그램이 성공적으로 컴파일되고 실행되고 있다. 이는 **타입 추론**이라는 기능 때문에 가능한 것이다.
    - 타입 추론은 대부분의 경우 컴파일러가 코드의 문맥에서 타입을 도출해주는 언어 기능이다.
    - 위에 코드에서 컴파일러는 toInt() 함수가 Int 타입의 값을 반환한다는 사실을 알고 있으며, 이 결과를 변수에 대입했기 때문에 변수 타입 또한 Int로 추론한다.
    - 타입 추론 덕분에 코틀린은 강한 타입 지정 언어인 동시에 사용자가 불필요한 타입 정보를 코드에 추가해서 코드가 지저분해지는 일을 막을 수 있다.
    - 자바 또한 자바 10부터 지역 변수 타입 추론을 제공해주나, 코틀린은 지역 변수뿐 아니라 더 넓은 요소에 대해 타입 추론을 해준다.

### 식별자

- 식별자는 변수나 함수 등 프로그램에 정의된 대상에 붙은 이름이다. 코틀린 식별자는 두 가지로 구분된다.
- 첫 번째는 자바 식별자와 비슷하며 다음 규칙을 만족하는 임의의 문자열이다.
    - 식별자는 오직 문자, 숫자, 밑줄 문자만 포함한다. 숫자로 식별자를 시작할 수는 없다.
    - 밑줄로만 이뤄질 수도 있다. 하지만 이런 식별자는 모두 미리 예약된 식별자이므로 일반적인 식별자로는 사용될 수 없다.
    - 하드 키워드는 식별자로 쓸 수는 없다.
        - 소프트 키워드는 특별한 문맥 제외 일반적인 식별자로 쓰일 수 있다.
- 두 번째는 작은역따옴표(`)로 감싼 식별자로, 두 작은역따옴표 사이에는 빈 문자열을 제외한 아무 문자열이나 와도 된다.
    
    ```kotlin
    val `fun` = 1
    val `name with spaces` = 2
    ```
    

### 가변 변수

- 불변 변수는 한번 초기화하면 다시는 값을 대입 할 수 없는 변수다. 이는 자바 final 변수와 비슷하다.
- 불변 변수를 사용하면 함수가 부수 효과를 일으키지 못하고, 함수형 스타일 코드를 장려할 수 있으며, 이로 인해 코드에 대한 추론이 쉬워지기 때문에 가능하면 불변 변수를 많이 사용해야 한다.
- 하지만 필요한 경우 val대신 var 키워드를 사용해 가변 변수를 정의할 수 있다. 기본적인 문법은 불변 변수의 경우와 같다. 대신 원할 때 변수 값을 얼마든지 바꿀 수 있다.
    - 처음 변수에 값을 대입할 때 추론된 변수 타입은 변수가 불변이든 그렇지 않든 계속 유지된다. 따라서 잘못된 타입의 값을 대입하면 컴파일 오류가 발생한다.
        
        ```kotlin
        var sum = 1
        sum = "Hello" <- 컴파일 에러 발생
        ```
        
- 자바와 달리 코틀린 대입은 문(`Statement`)이다. 따라서 아무 값도 돌려주지 않는다. 이로 인해 코틀린에서는 자바의 `a=b=c`와 같은 대입문 연쇄를 사용할 수 없다. 대입문이 값을 반환하지 않기 때문에 이전 대입의 결과를 다음 대입에 사용할 수 없기 때문이다.

### 식과 연산자

- 모든 식은 정해진 타입이 있으며, 이 타입은 연산이 만들어내는 값의 범위와 값에 허용되는 연산을 결정한다.
- 단항과 이항 연산마다 연산 순서를 결정하는 우선순위가 정해져 있다.
    - 우선순위가 같은 이항 연산자는 왼쪽에서 오른쪽으로 순서대로 계산된다.

## 2.2 기본 타입

- 자바에서는 `int`와 같은 원시 타입과 `String` 같이 클래스를 기반으로 하는 참조 타입 사이에 명확한 구분이 있었다.
- 반면에 코틀린에서는 똑같은 타입이 문맥에 따라 원시 타입과 참조 타입을 가리키기 때문에 이런 구분이 약간 모호하다.
    - 자바에서는 원시 타입을 감싸는 박싱 타입이 있지만, 코틀린은 필요할 때 암시적으로 박싱을 수행한다.
- 자바와 달리 모든 코틀린 타입은 근본적으로 어떤 클래스 정의를 기반으로 만들어진다. 즉, 원시 타입과 비슷한 타입들도 메서드와 프로퍼티를 제공한다.
    - 예를 들어 Double 타입에 정의된 `toInt()` 메서드를 호출할 수 있다. 이는 `Double` 값을 `Int` 값으로 변환해준다.
- 타입은 하위 타입이라는 개념으로 계층화할 수 있다. A타입이 B타입의 하위 타입이라는 말은 근본적으로 B 타입의 값이 쓰일 수 있는 모든 문맥에 A타입의 값을 넣어도 아무 문제가 없다는 뜻이다.
    - ex) 널을 허용하지 않는 모든 코틀린 타입은 `Any` 라는 내장 타입의 직간접적인 하위 타입이므로 아래와 같은 코드를 작성할 시, 1이라는 값을 박싱하게 만든다.
        
        ```kotlin
        val n: Any = 1
        ```
        
        정수 값 1이 기본 데이터 타입인 `Int`로 표현되는데, `Any` 타입으로 선언된 변수 `n`에 할당되고 있다. 이때 `Any`는 모든 타입의 슈퍼타입이므로, `Int` 타입의 값을 담을 수 있다. 그러나 `Any` 타입은 객체 타입이므로 기본 데이터 타입인 `Int`를 `Any`에 할당하기 위해 `Int` 값을 박싱하게 된다.
        

### 정수 타입

- 코틀린에는 정수를 표현하는 네 가지 기본 타입이 있다.

| 이름  | 크기(바이트) | 범위 | 대응하는 자바 타입 |
| --- | --- | --- | --- |
| Byte | 1 | -128 ..127 | Byte |
| Short | 2 | -32768 ..32767 | Short |
| Int | 4 | -2^31 ..2^31-1 | Int |
| Long | 8 | -2^63 ..2^63-1 | Long |
- 어떤 정수 타입 값을 표현하는 가장 간단한 리터럴은 10진수다.
- 코틀린 1.1 부터는 수 리터럴에 _를 넣어서 가독성을 높일 수 있다. 리터럴이 아주 큰 수를 나타낼 때 _가 유용하다.
- 리터럴에 L이나 l을 접두사로 붙이면 Long 타입이 된다.
- 앞에 0b(2진수)나 0x(16진수)를 붙여 2진수나 16진수로 수 리터럴을 작성할 수도 있다.
- 수 리터럴의 경우 0을 표현하는 경우가 아니라면 맨 앞에 0이 올 수 없다.
- 각 정수 타입에는 최솟값과 최댓값을 포함하는 상수 정의가 들어있다. 이런 상수를 사용하려면 앞에 타입 이름을 붙여야 한다.
    
    ```kotlin
    Short.MIN_VALUE
    Short.MAX_VALUE
    Int.MAX_VALUE + 1
    ```
    

### 부동소수점 수

- 코틀린도 자바와 마찬가지로 부동소수점 수를 따르는 Float와 Double을 제공한다.
- 부동소수점 수 리터럴 중 가장 단순한 형태는 10진 소수 형태로, 정수 부분과 소수 부분을 나눠 소수점(.)을 찍는다.
- 정수 부분이 비어있는 경우 정수 부분을 0으로 간주한다. 하지만 소수점을 남기면서 소수 부분을 생략할 수는 없다.
    
    ```kotlin
    val quarter = .25 // 0.25
    val one = 1. // 오류 발생
    ```
    
- 코틀린은 과학적 표기법 리터럴을 허용한다. 과학적 표기법에서는 e나 E뒤에 10을 몇 번 거듭제곱하는지를 알려주는 숫자가 온다.
    
    ```kotlin
    val pi = 0.314E1 // 3.14 = 0.314*10
    ```
    
- 부동소수점 리터럴은 디폴트로 `Double` 타입이고, f나 F를 리터럴 뒤에 붙이면 `Float` 타입이 된다.
- `Float` 리터럴은 `Double` 타입으로 자동 변환되지 않는다.

### 산술 연산

- 모든 수 타입은 기본 산술 연산을 지원한다. 산술 연산의 동작은 자바와 같다.
- 코틀린 1.5부터 표준 라이브러리에 정수 `floorDiv()`와 `mod()` 메서드가 추가됐다.
    - `floorDiv()`는 정수 나눗셈 연산과 마찬가지로 한 수를 다른 수로 나눈 몫을 계산한다.
    - `mod()` 메서드는 정수 나머지 연산과 마찬가지로 한 수를 다른 수로 나눈 나머지를 계산한다.

### 비트 연산

- Int와 Long은 비트 수준의 연산을 지원한다.

| 연산 | 뜻 | 자바 연산 |
| --- | --- | --- |
| shl | 왼쪽 시프트 | << |
| shr | 오른쪽 시프트 | >> |
| ushr | 부호 없는 오른쪽 시프트 | >>> |
| and | 비트 곱 (AND) | & |
| or | 비트 합 (OR) | | |
| xor | 비트 배타합(XOR) | ^ |
| inv | 비트 반전(inversion) | ~ |
- inv는 이항 연산이나 단항 연산이 아니라 점 표기법으로 호출하는 메서드일 뿐이라는 점에 유의해야 한다.
- 코틀린 1.1 부터는 Byte와 Short에도 or,xor,inv를 호출할 수 있다.

### 문자타입 Char

- Char 타입은 유니코드 한 글자를 표현하며 16비트이다. 이 타입의 리터럴은 작은따옴표(`) 사이에 문자를 넣으면 된다.
    
    ```kotlin
    val z = 'z'
    ```
    
- 새줄 문자와 같은 특수 문자를 위해 코틀린은 이스케이프를 제공한다.
    
    
    | 종류 | 의미 |
    | --- | --- |
    | \t | 탭 |
    | \b | 백스페이스 |
    | \n | 새줄 |
    | \r | 캐리지 리턴 |
    | \’ | 작은 따옴표 |
    | \” | 큰 따옴표 |
    | \\ | 역슬래시 |
    | \$ | 달러표시 |
- 내부에서 Char 값은 그냥 문자 코드일 뿐이지만, 코틀린은 Char 자체를 수 타입으로 취급하지는 않는다. 하지만 유니코드 문자 집합 내에서의 몇 가지 산술 연산을 허용한다.
    - +/- 연산자를 사용해 문자에 수를 더하거나 뺄 수 있다. 더하거나 뺀 수만큼 코드포인트가 이동한 새 문자를 반환한다.
    - 두 문자로 뺄셈을 하면 두 문자의 코드포인트 간 거리를 얻을 수 있다.
    - 문자를 ++ 또는 - - 로 증가시키거나 감소시킬 수 있다.
- 자바에서는 문자에 대한 산술 연산 결과가 암시적으로 정수로 변환된다. 반면 코틀린에서 Char에 대한 연산은 Char를 결과로 돌려준다.

### 수 변환

- 각 수 타입마다 값을 다른 수 타입으로 변환하는 연산이 정의돼 있다.
    - toByte(), toShort()…
- 자바와 달리 코틀린에서는 범위가 큰 타입이 사용돼야 하는 문맥에 범위가 작은 타입을 사용할 수 없다. 예를 들어 Int 값을 Long 변수에 대입할 수 없다.
    - 이렇게 하게 된 이유는 암시적인 박싱 때문이다. 일반적인 수 타입의 값이 꼭 원시 타입의 값으로 표현된다는 보장이 없다.
    - 따라서 더 큰 범위의 타입으로 변환하는 경우 다른 박싱한 타입의 값을 만들어낼 수 있는 가능성이 생기고, 이로 인해 동등성 요구 조건을 만족시키지 못하게 되면서 미묘한 오류를 발생시킬 수 있다.
        
        ```kotlin
        val n = 100 // Int
        val l: Long = n // Error
        
        println(l == n) // 만약 위에 코드를 올바를 코드로 인정하면 false를 출력하게 됨
        ```
        
    - 정수 타입 사이의 변환은 대상 타입이 더 큰 범위를 담는 타입인 경우 손실 없이 수행된다. 그렇지 않은 경우 MSB를 잘라내고 나머지를 대상 타입의 값으로 변환환다. Char 타입을 다른 타입의 값으로 바꾸거나 다른 타입의 값을 Char 타입으로 바꾸는 경우도 그렇다.
    - 부동소수점 수 타입과 관련된 변환의 경우, 일반적으로 대상 타입과 무관하게 정밀도를 잃을 수 있다.

### 불 타입과 논리 연산

- 코틀린은 참이나 거짓 중 하나로 판명되는 불(Boolean) 타입과 논리 연산을 제공한다.
- 자바와 마찬가지로 코틀린 `Boolean`도 수 타입과는 다른 타입이며, 암시적으로든 `toInt()`등의 명시적인 내장 연산을 써서든 수로 변환할 수 없다.
- 개발자는 비교 연산자나 조건식을 사용해 불이 아닌 값에서 불 값을 만들어야 한다.
- 불이 지원하는 연산은 다음과 같다
    - ! : 논리 부정
    - or, and, xor : 즉시 계산 방식의 논리합, 논리곱, 논리베타합
    - ||, && : 지연 계산 방식의 논리합, 논리곱
- 즉시 계산인 and, or, xor은 이름 붙은 중위 연산자와 같은 우선순위이므로 && 연산이나 || 연산보다 더 우선해 계산된다.

### 비교와 동등성

- 지금까지 언급한 모든 타입은 몇 가지 비교 연산을 제공한다.
    - == (같다)
    - != (같지 않다)
    - (~보다 작다)
    - <= (~보다 작거나 같다)
    - >  (~보다 크다)
    - >= (~보다 크거나 같다)
- 일반적으로 동등성 연산인 == 와 != 를 모든 타입의 값에 적용할 수 있다. 하지만 수 타입이나 Char와 Boolean의 경우 예외가 있다
    
    ```kotlin
    val a = 1
    val b = 2L
    println(a == b) // Error: comparing Int and Long
    ```
    
- 기본적으로 코틀린은 비교 시 모두 같은 타입일 때만 ==와 != 를 허용한다. 위에 코드 처럼 한 인자가 Int이고, 다른 인자가 Long이면 ==를 적용할 수 없다.
    - 값이 박싱돼 있는지에 따라 동등성 연산이 다른 결과를 낳을 수 있는데, 코틀린에서는 박싱이 암시적으로 진행되기 때문에 타입 사이의 동등성 연산을 허용하면 혼란을 야기할 수 있기 때문이다.
- 하지만 모든 수 타입의 값은 서로 <, <=, >, >=를 사용해 비교할 수 있다. 이는 수 타입 사이의 산술 연산이 가능한 모든 경우를 다룰 수 있도록 오버로딩된 것과 마찬가지다.
- 부동소수점 타입 비교 연산은 IEEE 754 표준을 따른다. 특히 이 표준은 NaN 값을 특별히 취급한다.
    - 기본적으로 NaN은 그 어떤 값과도 같지 않다. 특히 다른 NaN과도 같지 않고, 무한대를 포함한 다른 어떤 값보다 작지도 않고 크지도 않다.
    - NaN은 다음과 같은 특징을 가진다
        - NaN은 자기 자신과 같다
        - NaN은 Double에서 가장 큰 값으로 취급된다.

## 2.3 문자열

- String 타입은 문자들로 이뤄진 문자열을 표현한다.
- 자바와 마찬가지로 코틀린 문자열은 불변이다. 따라서  String 객체를 만들고 나면 그 안의 문자를 변경할 수 없고 문자열을 읽기만 할 수 있으며, 문자를 바꾸고 싶으면 기존 문자열을 바탕으로 새로운 문자열을 만들어야 한다.

### 문자열 템플릿

- 문자열 리터럴을 정의하는 가장 간단한 방법은 큰따옴표(”) 로 문자열을 감싸는 것이다.
- 문자열에 새줄 문자 같은 특수 문자가 들어가면 이스케이프 시퀀스를 사용해야 한다.
- 코틀린은 여러 가지 식에서 문자열을 합성해내는 훨씬 더 강력한 방법을 지원한다.
    
    ```kotlin
    fun main() {
    	val name = readLine()
    		println("Hello, $name!\n Today is ${Date()}")
    	}
    ```
    
    - 기본적으로 ${}의 중괄호 사이에 넣기만 하면, 어떤 올바른 코틀린 식이든 문자열에 넣을 수 있다.
    - `$name` 과 같이 이 식이 간단한 변수 참조인 경우에는 중괄호를 생략하고 달러 기호만 붙여도 된다. 이런 기능을 문자열 템플릿이라고 한다.
    - 문자열 템플릿 안의 식은 어떤 값이든 될 수 있다. 이 값은 자동으로 모든 코틀린 타입이 제공하는 `toString()` 매서드를 통해 문자열로 변환된다.
- 한 가지 다른 문자열 유형으로 로우 문자열이 있다. 로우 문자열을 사용하면 이스케이프 시퀀스를 사용하지 않고도 문자열 작성이 가능하다. 이 리터럴은 큰따옴표 세 대로 둘러싸여 있고, 새줄 문자를 포함한 임의의 문자를 포함할 수 있다.
    
    ```kotlin
    val message = """
    Hello, $name! Today is ${Date()}
    """.trimIndent()
    ```
    
    - `trimIndent()`는 여러 줄에 공통된 최소 들여쓰기를 제거해주는 표준 코틀린 함수다.

### 기본 문자열 연산

- 모든 String 인스턴스는 문자열에 든 문자 수를 표현하는 length와 문자열의 마지막 문자 인덱스를 표현하는 lastIndex 프로퍼티를 제공한다. 또한 인덱스를 각괄호 안에 넣는 연산자를 사용해 개별 문자에 접근할 수 있다.
- + 연산자를 사용해 두 문자열을 연결할 수 있다.
- 문자열은 == 와 !=를 사용해 동등성을 비교할 수 있다. 이들 연산을 문자열의 내용을 비교하므로, 서로 다른 두 객체 인스턴스를 비교해도 문자들의 순서와 길이가 같으면 같은 문자열로 간주한다.
    - 자바의 == 와 != 연산자는 참조 동등성을 비교하기 때문에 실제 문자열 내용을 비교하려면 `equals()` 메서드를 사용해야 한다. 그러나 코틀린에서는 == 가 기본적으로 `equals()` 를 가리키는 편의 문법이기 때문에 == 를 사용하면 직접 `equals()` 를 호출하므로, 따로 `equals()` 를 호출할 필요가 없다.
    - 코틀린에서 참조 동등성을 사용하고 싶으면 ===와 !== 연산자를 사용하면 된다.
- 문자열은 사전식 순서로 정렬되기 때문에 <, >, <=, >= 같은 연산자를 사용해 문자열을 비교할 수 있다.
- 문자열은 수 타입이나 불로 변환하는 toByte(), toShort(), toLong(), toFloat(), toDouble(), toBoolean()을 제공한다.
- 문자열이 제공하는 다른 유용한 함수들은 다음과 같다.
    
    
    | 함수 이름 | 역할 |
    | --- | --- |
    | isEmpty
    isNotEmpty | 문자열이 비어있는지 검사한다. |
    | substring | 부분 문자열을 추출한다. |
    | endsWith | 접두가나 접미사인지 검사한다. |
    | indexOf | 인자로 받은 문자나 문자열이 수신 객체인 문자열에 나타나는 첫번째 인덱스를 반환한다.  |

## 2.4 배열

- 배열은 내장된 코틀린 데이터 구조로, 미리 정해진 숫자만큼 같은 타입의 원소를 모아서 저장하고 각각을 인덱스로 참조할 수 있게 해준다.
- 코틀린 배열은 개념적으로 자바 배열과 비슷하며, 실제로 코틀린/JVM 애플리케이션에서는 자바 배열로 코틀린 배열을 표현한다.

### 배열 정의하기

- 배열 구조를 구현하는 가장 일반적인 코틀린 타입은 Array<T>다. 여기서 T는 원소의 타입을 뜻한다.
- 만들려는 배열의 크기를 미리 알 수 있다면 표준 함수 중 하나를 사용해 배열을 생성할 수 있다.
    
    ```kotlin
    val a = emptyArray<String>()
    val b = arrayOf("hello", "world")
    val c = arrayOf(1, 4, 9)
    ```
    
- 각 함수는 제네릭하다. 이는 호출할 때 원소의 타입을 지정해야 한다는 뜻이다. 하지만 위에 코드를 보면 알 수 있듯이 타입 추론 덕분에 타입 선언을 반드시 해야 할 필요는 없다.
- 코틀린은 ByteArray, ShortArray, IntArray, LongArray 등 타입에 특화된 배열을 제공한다.

### 배열 사용하기

- 배열 타입은 문자열 타입과 꽤 비슷하다. 특히 size와 lastIndex 프로퍼티가 있다는 점과 인덱스 연산으로 원소에 접근할 수 있다는 점이 비슷하다.
- 잘못된 인덱스를 통해 배열에 접근하면 IndexOutOfBoundsException 예외가 발생한다.
- 문자열과 달리 배열에서는 원소를 변경할 수 있다.
- 자바와 마찬가지로 배열 타입의 변수 자체에는 실제 데이터에 대한 참조를 저장한다. 이로 인해 배열 변수에 다른 배열을 대입하면 같은 데이터 집합을 함께 공유하게 된다.
- `copyOf()` 함수를 사용해 원본과 별도의 배열을 만들 수 있다. `copyOf()` 는 필요시 다른 크기의 배열을 만들어내기도 한다.
- 배열 타입 변수에 타입이 다른 배열은 대입할 수 없다. 코틀린 배열 타입은 모든 다른 배열 타입과 서로 하위 타입 관계가 성립하지 않는다고 간주되며, 이데 따라 앞에서 본 것 같은 대입도 금지된다.
- 배열을 생성하고 나면 그 길이를 바꿀 수 없지만, + 연산을 사용해 원소를 추가한 새로운 배열을 만들 수는 있다.
- 문자열과 달리 배열에 대한 ==와 != 연산자는 원소 자체를 비교하지 않고 참조를 비교한다. 배열 내용을 비교하고 싶으면 contentEquals() 함수를 사용해야 한다.