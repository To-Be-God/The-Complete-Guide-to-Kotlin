# 07 컬렉션과 I/O 자세히 알아보기

## 7.1 컬렉션

- 컬렉션을 조작하는 모든 연산은 인라인 함수다. 따라서 이런 연산을 사용해도 함수 호출이나 람다 호출에 따른 부가 비용이 들지 않는다.

### 컬렉션 타입

- 코틀린 컬렉션 타입은 기본적으로 네 가지로 분류할 수 있다.
    - 배열
    - 이터러블
    - 시퀀스
    - 맵
- 배열과 비슷하게 컬렉션 타입도 제네릭 타입이다. 컬렉션의 타입을 구제적으로 지정하려면 원소의 타입을 지정해야 한다.

**이터러블**

- 이터러블은 Iterable<T> 타입으로 표현되며, 일반적으로 즉시 계산되는 상태가 있는 컬렉션을 표현한다.
    - 상태가 있다는 말은 컬렉션이 원소를 필요할 때 생성하는 제너레이터 함수를 유지하지 않고 원소를 저장한다는 뜻이다.
    - 즉시 계산이라는 말은 나중에 어느 필요한 시점에 원소가 초기화되지 않고 컬렉션을 최초로 생성할 때 초기화된다는 뜻이다.
- 이터러블 타입은 원소를 순회할 수 있는 iterator()라는 메서드를 제공한다. 코틀린 for 루프에서는 이 메서드를 통해 모든 이터러블 객체를 활용할 수 있다.
- 이터러블 타입 내부에는 이터레이터가 컬렉션의 끝에 도달했는지를 판단하는 hasNext()와 컬렉션의 다음 원소를 반환하는 next() 메서드가 들어있다. 자바와 유일한 차이는 remove()가 없다 는 것인데, 이 메서는 MutableIterator로 옮겨졌다.
- 자바와 비교할 때 코틀린 이터러블의 중요한 특징은 불변 컬렉션과 가변 컬렉션을 구분한다는 점이다.
    - 불변 컬렉션은 생성한 다음에 내용을 바꿀 수 없지만, 가변 컬렉션은 언제든지 원소를 추가하거나 삭제할 수 있다.
    - 가변 이터러블의 기본 타입은 MutableIterable로 표현된다.
    - 불변 컬렉션 타입에서 유용한 특징으로는 공변성이 있다. 만약 T가 U의 하위 타입인 경우, Iterable<T>도 Iterable<U>의 하위 타입이라는 뜻이다.

**컬렉션, 리스트, 집합**

- Collection을 상속한 클래스는 크게 다음과 같이 분류할 수 있다.
    - 리스트는 인덱스를 통한 원소 접근이 가능한, 순서가 정해진 원소의 컬렉션이다.
    - ArrayList는 인덱스를 통한 임의 접근이 가능해 빠른 추가와 삭제가 가능하다.
    - LinkedList는 인덱스로 원소에  접근할 때 선형 시간이 걸린다.
- 집합은 유일한 원소들로 이뤄진 컬렉션이다. 원소의 순서는 구현에 따라 다르다.
    - HashSet은 해시 테이블이 기반인 구현이며, 원소의 해시 코드에 따라 원소 순서가 정해진다. 일반적으로 이 순서는 원소 타입의 hashCode() 메서드 구현에 따라 달라지므로 예측하기 어렵다.
    - LinkedHashSet은 해시 테이블이 기반이지만 삽인 순서를 유지한다.
    - TreeSet은 이진 검색 트리가 기반이며, 어떤 비교 규칙에 따라 일관성 있는 원소 순서를 제공한다. 원소 타입이 이런 비교 규칙을 정의할 수 있고, 별도의 Comparator 객체를 통해 비교 규칙을 제공할 수도 있다.

**시퀀스**

- 이터러블과 비슷하게 시퀀스도 iterator() 메서드를 제공한다. 다만 시퀀스는 지연 계산을 가정하기 때문에 iterator()의 의도가 이터러블과 다르다.
- 시퀀스의 구현은 내부적이므로 외부에서 직접 사용할 수 없다.

**맵**

- 맵은 키와 값 쌍으로 이뤄진 집합이다. 여기서 키는 유일해야 한다. 또한 맵에는 두 가지 종류의 원소가 들어있기 때문에 맵의 타입은 두 가지 타입을 파라미터로 받는 제네릭 타입이다.
- 맵 차제는 Collection의 하위 타입이 아니지만 맵에 들어있는 원소들을 컬렉션처럼 사용할 수 있다.

### Comparable과 Comparater

```kotlin
class Person( 
	val firstName: String, 
	val familyName: String,
	val age: Int
) : Comparable<Person> {
	val fullName get() = "$firstName $familyName"
	override fun compateTo(other: Person) = fullName.compareTo(other.fullName)
}
```

- 코틀린에서는 람다 비교 함수를 통해 비교기를 간결하게 작성할 수 있다.

    ```kotlin
    val AGE_COMPARATOR = Comparator<Person>{ p1, p2 -> p1.age.compareTo(p2.age)
    ```

- compareBy()나 compareByDescending() 함수를 통해 대상 객체 대신 사용할 수 있는 비교 가능 객체를 제공하게 함으로써 비교기를 만들 수도 있다.

    ```kotlin
    val AGE_COMPARATOR = compareBy<Person>{it.age}
    val REVERSE_AGE_COMPARATOR = compareByDescending<Person>{it.age}
    ```

- 비교기 인스턴스를 sorted()나 max() 처럼 순서를 인지하는 함수에 넘길 수 있다.

### 컬렉션 생성하기

- 자바와 마찬가지고 ArrayList나 LinkedHashSet 같은 클래스의 인스턴스를 생성자를 호출해 생성할 수 있다.
- 함수를 통해 컬렉션 클래스의 인스턴스를 생성할 수 있다.
    - emptyList()/emptySet():  불변인 빈 리스트/집합 인스턴스를 생성한다.
    - listOf()/setOf(): 인자로 제공한 배열에 기반한 불변 리스트/집합 인스턴스를 만든다.
    - listOfNotNull(): 널인 값을 걸러내고 남은 원소들로 이뤄진 새 불변 리스트를 만든다.
    - mutableListOf()/mutableSetOf(): 가변 리스트/집합의 디폴트 구현 인스턴스를 만든다.
        - 내부적으로 ArrayList, LinkedHashSet을 사용
    - arrayListOf(): 새로운 ArrayList를 만든다.
    - hashSetOf()/linkedSetOf()/sortedOf(): HashSet/LinkedHashSet/TreeSet의 새 인스턴스를 만든다.
- 맵을 만들 때도 비슷한 함수를 쓸 수 있다.
    - emptyMap(): 빈 불변 맵을 만든다.
    - mapof(): 새 불변 맵을 만든다.
    - mutableMapOf(): 가변 맵의 디폴트 구현 인스턴스를 만든다.
    - hashMapOf()/linkedMapOf()/sortedMapOf(): HashMap/LinkedHashMap/TreeMap의 새 인스턴스를 만든다.
    - 맵 함수는 pair 객체들로 이뤄진 가변 문자를 받는데 to 중위 연산자를 사용하면 이를 쉽게 만들 수 있다.

        ```kotlin
        val singletonMap = mapOf(10 to "Ten")
        ```

    - Pair을 생성하고 싶지 않다면 가변 맵을 만들고 set() 메서드나 인덱스 연산자를 사용해 맵에 원소를 추가할 수도 있다.
    - 배열과 비슷하게 크기를 지정하고 인덱스로부터 값을 만들어주는 함수를 제공함으로써 새 리스트를 만들 수도 있다.
- 시퀀스를 만드는 가장 단순한 방법은 sequenceOf() 함수를 사용하는 것이다. 이 함수는 가변 인자를 받는다.
    - 또는 배열, 이터러블, 맵 등의 기존 컬랙션 객체에 대해서는 asSequence() 함수를 호출해 시퀀스를 얻을 수도 있다.
    - 제너레이터 함수(generateSequnce()) 를 바당으로 만드는 방법도 있다.
    - 코틀린 1.3 부터는 특별한 빌더를 사용해 시퀀스를 만드는 방법이 추가되었다. 이때 빌더는 시퀀스 원소를 부분부분 지정한다. 빌더는 sequnce() 함수를 통해 빌더를 구현할 수 있으며, 빌더 안에는 다음과 같은 메서드가 있다.
        - yield(): 원소를 하나 시퀀스에 추가한다
        - yieldAll(): 지정한 이터레이터, 이터러블, 시퀀스에 들어있는 모든 원소를 시퀀스에 추가한다.
        - 시퀀스는 지연 계산되기 때문에 각 부분에 속한 원소에 접근하는 경우에만 위에 메서드들이 호출된다.
        - 이 시퀀스 빌더는 유예 가능 계산 기능을 가지고 있기 때문에 다중 스레드 환경에서 매우 유용하다.

### 기본 컬렉션 연산

- 모든 컬렉션이 기본으로 지원하는 공통 연산으로는 이터레이션이 있다. 배열, 이터러블, 시퀀스, 맵은 iterator() 함수를 지원한다.

**컬렉션 반복**

- iterator() 함수가 있다는 것은 모든 컬렉션에 대해 for 루프를 쓸 수 있다는 것을 의미한다.
- for 루프의 대안으로는 forEach() 확장 함수가 있다. 이 함수는 컬렉션의 각 원소를 제공하면서 인자로 받은 람다를 실행해준다.
- 원소 인덱스를 참조해야 한다면 forEachIndexed() 함수를 사용하면 된다.

**존재 여부**

- 컬렉션 타입이 제공하는 기본 기능은 다음과 같다.
    - size 프로퍼티는 원소 개수를 돌려준다.
    - isEmpty() 함수는 컬렉션에 원소가 없는지 검사한다.
    - contains()/containsAll() 함수는 인자로 지정한 원소나 인자로 지정한 컬렉션의 모든 원소가 수신 객체 컬렉션에 들어있는지 검사한다.
- contains 함수 호출은 in 연산자로 대신할 수 있다.

**원소 추가/삭제**

- MutableCollection 타입은 원소를 추가하거나 제거할 수 있는 메서드를 제공한다.
- add()/remove()/addAll()/removaAll() 대신 +=나 -= 복합 연산을 사용할 수도 있다.
- 불변 컬렉션이든 가변 컬렉션이든 +와 -연산자를 지원한다. 두 연산자 모두 원본은 그대로 두고 새로운 컬렉션을 생성한다.

**원소 접근/수정**

- 리스트도 배열처럼 원소를 인덱스로 접근할 수 있는 메서드를 제공한다. 일반적으로 인덱스를 사용하는 방식이 좋다.
- 리스트가 가변 리스트인 경우에는 인덱스를 사용해 원소를 변경할 수도 있다.
- subList() 함수는 시작 인덱스와 끝 인덱스로 지정한 리스트의 일부분에 대한 래퍼를 만든다. 이 뷰는 원본 컬렉션의 데이터를 공유하기 때문에 가변 리스트의 경우 뷰와 원본의 변화가 서로 반영된다.

**집합, 맵**

- 집합 구현은 Collection에 있는 공통 메서드만 지원한다. 집합은 컬렉션에 원소를 추가할 때 중복을 허용하지 않는다.
- Map 인스턴스는 키를 사용해 값을 얻는 메서드(`get()`)와 모든 키나 값의 컬렉션(`keys` , `values` …) 을 돌려주는 메서드들을 지원한다.

### 컬렉션 원소에 접근하기

- first()/last() : 각각 주어진 컬렉션의 첫 번째와 마지막 원소를 반환하고, 컬렉션이 비어있으면 `NoSuchElementException` 을 발생시킨다.
    - 원소가 없으면 Null을 반환하는 안전한 버전인 firstOrNull()/lastOrNull() 도 있다.
- 함수에 술어를 넘겨 주어진 조건을 만족하는 첫 번째나 마지막 원소를 찾을 수 있다.

    ```kotlin
    println(listOf(1,2,3).first {it>2})
    ```

- single() 함수는 싱글턴 컬렉션의 원소를 반환한다. 컬렉션이 비어있거나 원소가 두 개 이상이면 예외를 던진다.
- elementAt() 함수를 사용하면 인덱스를 사용해 컬렉션 원소를 읽을 수 있다. 이는 리스트의 get() 함수를 일반화한 것으로 배열, 이터러블, 시퀀스 등에 모두 적용할 수 있다.
    - 인덱스가 잘못된 경우 예외를 던진다.
        - elementAtOrNull() : 인덱스가 경계를 벗어날 때 널을 반환
        - elementAtOrElse() : 인덱스가 경계를 벗어난 경우 지정된 람다가 반환하는 원소를 반환
- 배열이나 리스트에 대한 구조 분해를 통해 앞에서부터 최대 다섯 개의 원소를 추출할 수 있다.

### 컬렉션에 대한 조건 검사

- all() 함수는 컬렉션의 모든 원소가 주어진 술어를 만족하면 true를 반환한다. 배열, 이터러블, 시퀀스, 맵 등 모든 컬렉션 객체에 대해 이 함수를 적용할 수 있다.
- none()함수는 all()과 반대로 컬렉션에 주어진 조건을 만족하는 원소가 하나도 없을 때 true를 반환한다.
- any()는 컬렉션 원소 중 적어도 하나가 주어진 술어를 만족할 때 true를 반환한다.
- 빈 컬렉션의 경우 all()과 none() 함수는 true를, any() 함수는 false를 반환한다.

### 집계

**집계값을 계산**

- count()는 컬렉션의 원소 개수를 반환한다. 배열, 이터러블, 시퀀스, 맵을 포함하는 모든 컬렉션 객체에 이 함수를 적용할 수 있다.
    - 이 함수는 배열, 맵, Collection 인스턴스가 제공하는 size 프로퍼티를 일반화한 함수다.
    - 원소 개수가 Int.MAX_VALUE보다 크면 예외를 던진다.
    - 함수에 술어를 넘겨 주어진 조건을 만족하는 원소의 개수를 구할 수도 있다.
- sum() 함수는 수로 이뤄진 배열, 이터러블, 시퀀스의 산술 합계를 구한다.
- sumOf()를 사용하면 원소를 변환하는 함수를 제공함으로써 비교할 수 없는 원소들도 변환을 통해 합계를 구할 수 있다.
- average() 함수는 수로 이뤄진 배열, 이터러블, 시퀀스의 산술 평균을 구한다. 결과는 항상 Double이다.
    - 컬렉션이 비어있으면 average() 함수는 항상 Double.NaN을 반환한다.
    - 원소 개수가 Int.MAX_VALUE보다 크면 예외를 던진다.
- minOrNull()과 maxOrNull()은 비교 가능한 타입의 값이 들어있는 배열, 이터러블, 시퀀스의 최솟값과 최댓값을 계산한다.
- sumOf()와 마찬가지로 minByOrNull()과 maxByOrNull() 함수를 사용해 비교 가능한 값으로 원소를 변환할 수 있다.
- minWithOrNull(), maxWithOrNull()은 변환 함수 대신 비교기를 받아서 변환한다.
- 빈 컬렉션에 대해 적용하는 경우 min/,ax 집계 함수의 모든 변형은 널을 반환한다.

**문자열로 통합**

- 컬렉션 원소를 문자열로 엮는 기본 함수는 joinToString() 이며, 가장 단순한 형태로 사용할 때 아무 인자도 받지 않는다.
    - joinToString()은 어떠한 배열, 이터러블, 시퀀스에도 사용할 수 있다.
- 디폴트로 각 원소를 toString() 메서드를 이용해 문자열로 변환한 후에 구분 문자열로 콤마와 공백을 사용한다. 이때, 커스텀 변환 함수를 제공해 원소를 다른 형태의 문자열로 변환할 수 있다.

    ```kotlin
    println(listOf(1,2,3).joinToString{it.toString(2)}) // 2진수로 표현
    ```

- 코틀린 라이브러리는 더 일반적인 joinTo() 함수를 제공한다. 이 함수는 문자열을 새로 생성하는 대신 파라미터로 받은 Appendable 객체 뒤에 덧붙여준다.

**함수를 활용해 임의의 집계 방식을 구현**

- reduce() 함수는 첫 번째 인자로 누적된 값을 받고, 두 번째 인자로 컬렉션의 현재 값을 받는다. 집계 과정은 다음과 같다.
    - 누적값은 최초에 컬렉션의 첫 번째 원소로 초기화된다.
    - 컬렉션의 매 원소에 대해 현재 누적값과 현재 원소를 파라미터로 받은 함수에 적용하고 이 함수 적용의 결과를 누적값에 대입한다.
    - 누적의 결과를 반환한다.
    - 컬렉션이 비어있으면 누적값을 초기화할 수 없으므로 reduce() 함수는 예외를 던진다.
- 집계 규칙이 원소의 인덱스에 따라 달라진다면 reduceIndexed()를 사용할 수 있다.
- 누적값의 초깃값을 원하는 대로 지정하고 싶다면 fold()/foldIndexed()를 사용하면 된다.
    - 항상 누적값의 초깃값을 지정하기 때문에 리스트가 비어있어서 fold()는 reduce()와 달리 예외를 발생시키지 않는다.

### 걸러내기

- 걸러내기 연산은 원본 컬렉션을 변경하지 않는다. 대신 전혀 새로운 컬렉션을 만들거나 원본 컬렉션과 구별되는 기존 가변 컬렉션에 선택된 원소를 추가한다.
- 가장 기본적인 걸러내기 연산은 filter() 함수에 의해 제공된다.
    - Array<T>나 Iterable<T>를 거르면 List<T>를 얻는다.
    - Map<K,V>를 거르면 Map<K,V>를 얻는다.
    - Sequence<T>를 거르면 Sequence<T>를 얻는다.
- 맵의 경우 키나 값만 걸러내고 싶다면 filterKeys()나 filterValues() 함수를 사용하면 된다.
- filterNot() 함수는 조건을 부정해 걸러낼 수 있게 해준다. 즉, 술어가 false를 반환할 때만 원소를 남긴다.
    - 위에 있는 filterKeys()나 filterValues() 함수는 filterNot()과 같은 부정 병형이 없다.
- 걸러내는 조건이 원소의 값뿐 아니라 인덱스와도 관련 있다면, 람다가 인덱스 값을 추가로 받는 filterIndexed()를 사용하면 된다. 맵은 해당 함수를 제공하지 않는다.
- 널인 원소를 걸러내려면 filterNotNull()을 사용하면 된다.
- 원소 중 특정 타입만 남기는 경우는 filterIsInstance()를 사용하면 된다.
- partition() 함수를 제공하면 주어진 술어를 만족하는 부분 컬렉션과 만족하지 않는 부분 컬렉션의 쌍으로 만들어준다.

### 변환

**매핑 변환**

- 매핑 변환은 주어진 함수를 원본 컬렉션의 각 원소에 적용한다. 그리고 함수를 적용한 결과를 새로운 컬렉션의 원소가 된다.
- 이 유형에 속하는 기본 함수는 map()이다. 배열, 이터러블, 시퀀스 맵을 포함하는 모든 컬렉션 객체가 이 함수를 제공한다.
- map()의 결과는 시퀀스에 적용한 경우에는 시퀀스, 그렇지 않은 경우에는 리스트가 된다.
- 변환 시 인덱스를 고려해야 하는 경우 mapIndexed() 함수를 사용할 수 있다.
- 널이 아닌 값만 선택하려면 함수명 뒤에 NotNull을 붙여야 한다.
- map() 함수를 맵에 적용한 경우, 키와 값만 변환하고 싶다면 mapKeys()와 mapValues() 함수를 사용하면 된다.

**평평하게 하는 연산**

- 평평하게 하는 연산은 원래 컬렉션의 각 원소를 컬렉션으로 변환한 다음, 각 컬렉션을 차례로 이어 붙여서 한 컬렉션으로 합쳐준다.
- 이를 flatMap()을 통해 구현할 수 있다.
- flatten() 함수는 원소가 컬렉션인 모든 컬렉션에 적용할 수 있고 각각의 컬렉션을 이어 붙인 한 컬렉션을 내놓는다.
- map()와 마찬가지로 flatMap() 함수에도 결과 원소를 기존 컬렉션에 추가하는 버전이 있다.

```kotlin
println(setOf("abc", "def", "ghi").flatMap {it.asIterable()}
println(listOf(listOf(1,2), setOf(3,4), listOf(5)).flatten())

val result = ArrayList<String>()

listOf(listOf("abc", "def"), setOf("ghi"))
	.flatMapTo(result) {it}
sequenceOf(sequeceOf(1,2), sequenceOf(3,4))
	.flatMapTo(result) {it.map {"$it"}}

println(result) // [abc, deg, ghi, 1, 2, 3, 4]
```

**연관짓기**

- 주어진 변환 함수를 바탕으로 원본 컬렉션 원소를 맵의 키나 맵의 값으로 만들 수 있는 변환이다.
- associateWith() 함수는 원래 컬렉션을 키의 근원으로 사용해 새로운 맵을 만들어준다.

    ```kotlin
    println(
    		listOf("red", "green", "blue").associateWith {is.length}
    	) // {red = 3, green = 5, blue = 4}
    ```

- 배열에는 associateWith()를 적용할 수 없다.
- associateBy() 함수는 associateWith()와 비슷하지만 컬렉션 원소를 값으로 취급하고 변환 함수를 통해 키를 얻는다는 점이 다르다. 다만 어떤 키에 대해 같은 값이 여럿 존재하는 경우, 오직 한 값만 반환되는 맵에 남는다는 점을 유의해야 한다.
- associate() 함수는 컬렉션의 원소를 사용해서 키와 값을 만들어낸다.

### 하위 컬렉션 추출

- 리스트의 세그먼트에 대한 뷰를 돌려주는 subList와 달리 slice()는 정수 쌍 대신 정수 범위를 사용해 세그먼트의 경계를 표현한다. 그리고 slice() 함수는 리스트뿐 아니라 배열에도 적용할 수 있다.
- 리스트의 경우 slice()의 동작은 subList()와 비슷하며, 원 컬렉션을 반영할 수 있는 래퍼 객체를 만들어낸다.
- 배열의 경우 slice()는 지정한 인덱스들에 속하는 배열 원소가 들어있는 새로운 리스트다.
- 배열 원소를 다른 배열로 추출하고 싶다면 sliceArray()를 사용해야 한다.
- take()와 takeLast() 함수는 이터러블이나 배열에서 원소를 주어진 개수만큼 추출한다. take()는 맨 앞에서부터, takeLast()는 맨 뒤에서부터 개수를 센다.
- drop()/dropLast() 함수는 주어진 개수만큼 원소를 제거한 나머지 원소들을 돌려준다.
- chunked() 함수를 사용하면 이터러블이나 시퀀스를 주어진 개수를 넘지 않는 작은 리스트들로 나눠준다.
- windowed() 함수는 일정한 간격으로 청크를 연속적으로 얻어낸 슬라이딩 윈도우를 얻을 수 있다.

### 순서

- 가장 간단한 형태는 sorted() 함수로, 원소 타입이 비교 가능한 배열/이터러블/시퀀스에 적용할 수 있고 원소들의 자연스러운 순서에 따라 오름차순으로 원소를 정렬한다.
- sortedDescending() 함수는 내림차순으로 원소를 정렬한다.
- 정렬 함수를 배열이나 이터러블에 대해 적용하면 항상 list가 나온다.
- 컬렉션 원소가 비교 가능하지 않아도, 순서를 제공함으로써 sorted()를 대체할 수 있는 sortedBy(), sortedWith()를 통해 정렬할 수 있다.
    - sortedBy()는 컬렉션 원소를 비교 가능한 타입의 값으로 변환하는 함수를 인자로 받는다.
    - sortedWith()는 비교기 인스턴스를 인자로 받는다.
- reversed() 함수는 원본 컬렉션의 원소를 역순으로 나열한 새 리스트를 반환한다.
- 새 컬렉션을 만들지 않고 제자리에서 가변 리스트나 배열의 원소 순서를 뒤집을 때는 reverse()를 사용하고, asReversed()은  reverse()와 비슷하나 원본 리스트의 데이터를 공유 즉 래퍼를 만들어 반환한다는 점에서 다르다.
- suffled()을 이터러블에 적용하면 원본의 원소를 임의의 순서대로 재배치한 새 리스트를 만들어 준다.

## 7.2 파일과 I/O 스트림

### 스트림 유틸리티

- 다음 함수를 사용하면 스트림의 전체 콘텐츠를 읽어올 수 있다

    ```kotlin
    fun InputStrea.readBytes(): ByteArray
    fun Reader.readText(): String
    fun Reader.readLines(): Line<String>
    ```

- readLine()은 스트림에서 한 줄을 가져오지만, readText()/readLines()는 스트림 끝까지 콘텐츠를 읽어서 전체를 한 문자열이나 각 줄을 나타내는 문자열의 리스트로 반환한다.
- readText()와 달리 readLines()함수는 값을 반환하면서 스트림을 닫아준다.
- 코틀린은 버퍼가 있는 스트림에 대한 직접 이터레이션을 허용한다. BufferedOutputStream의 경우에는 iterator()가 있기 때문에 for 루프에서 스트림을 사용해 개별 바이트에 대해 이터레이션 할 수 있다.
- Reader 인스턴스에 대해서도 비슷한 기능을 제공한다. forEachLine()과 useLines() 함수는 줄 단위 이터레이션을 허용한다. 이 두 함수는 스트림을 자동으로 닫아준다.
  - forEachLine()에 전달되는 람다는 이터레이션이 진행되면서 한 줄씩 데이터를 인자로 전달받는 반면, useLines()에 전달되는 람다는 모든 라인에 대한 시퀀스를 인자로 받는다는 점이 다르다.
- copyTo() 함수를 사용하면 한 스트림에서 다른 스트림으로 데이터를 전달할 수 있다. 이 함수는 이진 데이터와 텍스트 데이터를 처리하는 오버라이딩된 버전이 존재한다.
- use() 함수는 명시적으로 정리해야 하는 스트림이나 다른 자원을 안전하게 처리할 수 있는 방법을 제공한다. use() 함수는 java.io.Closeable 타입의 값에 대해 호출할 수 있으며 인자로 전달받은 람다를 실행하고 나서 마지막에 자원을 적절히 정리해준 후 람다의 결과를 돌려준다.
  - 자바 try-with-resources와 같은 역할을 함

### 스트림 생성

- bufferedReaders()/bufferedWriter() 확장 함수를 사용하면 지정한 File 객체에 대해 BufferedReader/BufferedWriter 인스턴스를 만들 수 있다.
- 비슷하게 reader()/writer() 확장 함수를 사용하면 각각 버퍼가 없는 FileRedaer/FileWriter 객체를 만든다.
- 이진 파일을 처리하고 싶다면 inputStream()/outputStream()을 사용해 적절한 스트림을 생성하면 된다.
- byteInputStream()함수는 주어진 문자열을 원본으로 하는 ByteArrayInputStream 인스턴스를 만든다. 비슷하게 reader() 함수는 StringReader 인스턴스를 만든다.
- inputStream() 함수는 주어진 바이트 배열을 원본으로 하는 ByteArrayInputStream 인스턴스를 만든다. 해당 함수가 오버로딩된 버전을 사용하면 오프셋과 크기를 지정해서 바이트 배열 중 일부분만 사용해 스트림을 만들 수 있다.

### URL 유틸리티

- readText() 함수는 URL 인스턴스에 해당하는 입력 스트림의 콘텐츠를 전부 읽어온다.
- readBytes() 함수도 비슷하게 입력 이진 스트림의 콘텐츠를 바이트 배열로 읽어온다.
- 두 함수 모두 전체 스트림 콘텐츠를 읽어오는 작업이 완료될 때까지 스레드를 블럭시키므로, 큰 파일을 다운로드할 때는 사용하면 안된다.

### 파일 콘텐츠 접근하기

- readText(): 파일 콘텐츠 전부를 한 문자열로 읽어온다.
- readLines(): 파일 콘텐츠 전부를 줄 구분 문자를 사용해 줄 단위로 나눠 읽어서 문자열의 리스트 반환
- writeText(): 파일 콘텐츠를 주어진 문자열로 설정한다. 필요하면 파일을 덮어 쓴다.
- appendText(): 주어진 문자열을 파일의 콘텐츠 뒤에 추가한다.
- forEachBlock(): 이진 파일을 처리할 때 사용한다.

### 파일 시스템 유틸리티

- deleteRecursively() 함수를 사용하면 파일이나 디렉터리를 자신에게 포함된 자손들까지 포함해 쉽게 지울 수 있다. 이 함수는 삭제가 성공하면 true, 실패하면 false를 반환한다.
- copyTo() 함수는 자신의 수신 객체를 다른 파일에 복사하고 복사본을 가리키는 파일 객체를 돌려준다.
  - 대상 파일이 이미 존재하는 경우 예외를 발생시킨다.
- walk() 함수는 깊이 우선 디렉터리 구조 순회를 구현한다. 순회 방향을 결정하는 파라미터는 다음과 같다.
  - TOP_DOWN: 자식보다 부모를 먼저 방문
  - BOTTOM_UP: 자식을 부모보다 먼저 방문
- onEnter()와 onLeave() 함수는 순회가 디렉터리에 들어가거나 디렉터리에서 나올 때 호출할 동작을 지정한다.
  - onEnter() 호출은 (File) → Boolean 람다를 파라미터로 받고, 이 람다의 반환값은 디렉터리를 방문할지 여부를 결정한다.
  - onLeave() 호출은 (File) → Unit 람다를 받는다.
- onFail() 함수를 통해 디렉터리의 자식에 접근할 때 IOException이 발생하는 경우에 호출될 액션을 정할 수 있다. 이 액션은 (File, IOException) → Unit 타입의 람다이며, 문제가 되는 디렉터리와 발생한 예외를 인자로 받는다.