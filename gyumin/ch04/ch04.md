# 4장 클래스와 객체 다루기


## 4.1 클래스 정의하기

### 4.1.1 클래스 내부 구조

* 코틀린의 클래스 선언 방법은 자바와 동일하게 class 키워드를 통해 선언하면 됩니다.

```Kotlin
class Person{
    var firstName: String =""
    var familyName : String = ""
    var age : Int = 0
    
    fun fullName() = "$firstName $familyName"
    
    fun showMe(){
        println("${fullName()} : $age")
    }
}
```

* 코틀린에서 프로퍼티가 사용하는 내부 필드는 항상 캡슐화돼 있고 클래스 정의 밖에서는 이 내부 필드에 접근할 수 없습니다.
* 기본적으로 코틀린 클래스는 public 가시성을 가집니다. 또한 internal, private을 통해 가시성을 제한할 수 있습니다.
* 코틀린에서는 소스 파일의 이름을 그 안에 들어있는 공개 클래스 이름과 똑같이 만들 필요가 없습니다. 즉, 한 파일 내부에 여러 클래스가 존재할 수 있습니다.

### 4.1.2 생성자

* 생성자는 클래스 인스턴스를 초기화해주고 인스턴스 생성 시 호출되는 특별한 함수입니다.
```Kotlin
class Person(firstName: String, familyName: String){
    val fullName = "$firstName $familyName"
}
```

* class 키워드 이름 뒤에 덧붙인 파라미터 목록을 통해 인스턴스를 생성할 때, 넘겨줄 파라미터를 정의할 수 있습니다.
* 클래스 헤더의 파라미터 목록을 주 생성자 선언이라고 합니다.
* 주생성자는 함수와 달리 본문이 하나가 아닙니다. 대신 주생성자는 클래스 정의 내에서 프로퍼티 초기화와 초기화 블록이 등장하는 순서대로 구성됩니다.

```
The primary constructor initializes a class instance and its properties in the class header. 
The class header can't contain any runnable code. 
If you want to run some code during object creation, use initializer blocks inside the class body. 
Initializer blocks are declared with the init keyword followed by curly braces. 
Write any code that you want to run within the curly braces.
```

* 생성자에서 함수를 정의할 수 없지만, 이를 init block을 통해 할 수 있습니다.
* 컴파일러는 모든 프로퍼티가 확실히 초기화되는지 확인합니다.
* 주생성자 파라미터를 프로퍼티 초기화나 Init 블록 밖에서 사용할 수 없습니다.
* 코틀린은 간단하게 생성자 파라미터의 값을 멤버 프로퍼티로 만들 수 있는 방법을 제공합니다.
* val, var 파라미터를 사용하면 단순하지 않은 멤버가 포함되지만 본문은 비어있는 클래스를 정의할 수 있습니다.
* 코틀린 constructor 키워드를 통해 부생성자를 정의할 수 있습니다. 
* 부생성자에 반환 타입을 지정할 수 없지만, 기본적으로 Unit 타입 값을 반환하는 함수와 마찬가지 입니다.
* 클래스에 주생성자를 선언하지 않을 경우, 모든 부생성자를 호출하기 전, init 블록을 실행합니다.

### 4.1.3 멤버 가시성

* 코틀린에서의 가시성은 다음과 같습니다.
  * public
  * internal
  * protected
  * private

### 4.1.4 내포된 클래스

* 함수, 프로퍼티, 생성자 외에 코틀린 클래스는 다른 클래스도 멤버로 가질 수 있습니다. 이를 내포된 클래스라고 부릅니다.

```Kotlin
class Person(val id: Id, val age: Int){
    class Id(val firstName: String, val familyName: String)
    fun showMe() = println("${id.firstName} ${id.familyName}, $age")
}
```

* 내포된 클래스에 inner를 붙이면 자신을 둘러싼 외부 클래스의 현재 인스턴스에 접근할 수 있습니다.
* 내부 클래스 본문에서 외부 클래스 인스턴스를 가리켜야 한다면 한정시킨 this 식을 사용해야 합니다. 한정시킬 때는 @와 외부클래스 이름을 통해 지정할 수 있습니다.

### 4.1.5 지역 클래스

* 자바처럼 코틀린에서도 함수 본문에서 클래스를 정의할 수 있습니다. 이런 지역 클래스는 자신을 둘러싼 코드 블록안에서만 쓰일 수 있습니다.
* 지역 함수와 비슷하게 코틀린 지역 클래스도 자신을 둘러싼 코드의 선언에 접근할 수 있습니다.
* 내포된 클래스와 달리 지역 클래스에는 가시성 변경자를 붙일 수 없습니다.
* 지역 클래스의 영역은 항상 자신을 둘러싼 블록으로 제한됩니다.
* 지역 클래스도 함수, 프로퍼티, 생성자, 내포된 클래스 등 다른 클래스가 포함할 수 있는 모든 멤버를 포함할 수 있습니다. 하지만 내포된 클래스는 반드시 inner 클래스여야 합니다.
* 지역 클래스 안에 내부 클래스가 아닌 내포된 클래스를 허용하지 않은 이유는 내포된 클래스 특성상 지역 클래스 안에 있는 내포된 클래스는 자신의
외부 클래스에서 사용할 수 있는 상태에 접근할 수 없으며, 구문 영역에 따른 변수 가시성 규칙이 지역 클래스 안의 내포된 클래스에서만 동작하지 않으면 혼동을 야기하기 때문입니다.

## 4.2 널 가능성

* 자바에서의 NPE는 컴파일러가 정적인 타입 정보만으로 오류를 잡아낼 수 없어 런타임에 오류를 찾아야하기 때문에 최악입니다.
* 코틀린에서는 널을 컴파일타임에 널 가능 여부를 구분할 수 있기에 NPE 발생을 상당부분 막을 수 있습니다.

### 4.2.1 널이 될 수 있는 타입

* 코를린은 널 여부를 결정할 수 있으며, 기본적으로 널이 될 수 없는 타입을 가집니다.
* 코틀린에서 널 가능 여부를 표현하기 위해 '?'를 사용합니다.
* 런타임에 널이 될 수 없는 값은 실제로 널이 될 수 있는 값과 차이가 없습니다. 이는 런타임에서의 오버헤드가 없음을 의미합니다.
* 널이 될 수 있는 타입은 원래 타입에서 제공하는 프로퍼티, 메소드들에 접근할 수 없습니다.

### 4.2.2 널 가능성과 스마트 캐스트

* 코틀린의 스마트 캐스트를 통해 널이 될 수 있는 값을 널이 될 수 없는 값으로 변환해줍니다.
* 스마트 캐스트는 널 가능성뿐만 아니라 클래스 계층 구조안에서 스마트 캐스트를 통해 안전한 타입 캐스팅을 수행할 수 있습니다.
* 스마트 캐스트를 실행하려면 대상 변수의 값이 검사 지점과 사용 지점 사이에서 변하지 않는다고 컴파일러가 확신할 수 있어야 합니다.

### 4.2.3 널 아님 단언 연산자

* !! 연산자는 널 아님 단언이라고 부릅니다.
* 단언 연산자는 KotlinNPE를 발생시킬 수 있는 연산자 입니다.
* 단언 연산자를 사용하여 컴파일러가 안전한지 인식하지 못하는 상황보다는 코드 제어흐름 변경을 통해 스마트 캐스트를 적용할 수 있게하는게 좋습니다.

### 4.2.4 안전한 호출 연산자

* 코틀린에서의 널이 될 수 있는 타입은 해당 원래 타입에서 제공하는 함수 등에 접근할 수 없지만, 안전한 호출 연산을 통해 앞선 제약을 피할 수 있습니다.
* 안전한 호출 연산은 변수 뒤에 '?' 선언 후, 메소드 호출이나 프로퍼티 조회가 가능합니다. 이는 해당 변수가 널인 경우 호출하지 않고, 널이 아닌 경우 해당 호출을 수행합니다.
즉, '수신 객체가 널이 아닌 경우에는 의미 있는 일을 하고, 수신 객체가 널인 경우에는 널을 반환하라'를 내포하고 있습니다.

### 4.2.5 엘비스 연산자

* 널이 될 수 있는 값을 다룰 때 널 복합 연산자(?:)를 통해 해당 값이 널인 경우일 때의 행위, 값을 지정할 수 있습니다.
* 우선순위 면에서 엘비스 연산자는 or 등의 중위 연산자와 in, !in 사이에 위치합니다. 특히, 비교/동등성 연산자나 ||, &&, 대입보다 더 우선순위가 높습니다.