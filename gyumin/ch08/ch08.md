# 8장 클래스 계층 이해하기

## 8.1 상속

* 코틀린은 자바와 마찬가지로 단일 상속만 지원합니다.
* 상속을 지정하지 않으면 컴파일러는 자동으로 Any를 상속하는 것으로 가정합니다.

### 8.1.1 하위 클래스 선언

* 어떤 클래스를 상속하려면, 클래스를 정의하면서 주 생성자 뒤에 :을 넣으면 됩니다.

```Kotlin
open class Vehicle{
    var currentSpeed = 0
    
    fun start(){
        println("i'm moving")
    }
    
    fun stop(){
        ...
    }
}

open class FlyingVehicle: Vehicle(){
    ...
}
```

* 코틀린의 클래스는 기본적으로 상속 불가(final class)이기 때문에 `open` 키워드를 통해 해당 클래스가 상속할 수 있도록 지정할 수 있습니다.
* 인라인 클래스는 다른 클래스를 상속할 수 없으며, 다른 클래스의 상위 클래스 역할도 할 수 없습니다.
* 상속은 임의 다형성이라는 강력한 기능을 제공합니다.
    * 임의 다형성은 상위 클래스 멤버의 여러 다른 구현을 하위 클래스에서 제공하고, 런타임에 실제 인스턴스가 속한 클래스에 따라 구현을 선택해주는 기능입니다.

```Kotlin
open class Vehicle{
    open fun start(){
        ...
    }
    
    fun stop(){
        ...
    }
}

class Car: Vehicle(){
    overrride fun start(){
        ...
    }
}

class Boat: Vehicle(){
    overrride fun start(){
        ...
    }
}

fun startAndStop(vehicle: Vehicle){
    vehicle.start()
    vehicle.stop()
}

fun main(){
    startAndStop(Car())
    startAndStop(Boat())
}
```


* 코틀린은 자바와는 다르게 무조건 override를 명시해줘야합니다. 
이는 실수로 상위 메소드와 같은 이름을 가지는 메소드를 만들어 예상하지 못한 버그를 만들어내는것을 방지하기 위함입니다.
* 상위 클래스에서 정의된 메소드와 똑같은 이름과 시그니처를 가지는 확장 함수를 정의하더라도 상위 클래스의 메소드를 호출하게 됩니다.
* 코틀린은 메소드뿐만 아닌 프로퍼티도 오버라이드할 수 있습니다.
* 함수나 프로퍼티를 오버라이드할 때, 상위 클래스에서 정의한 값을 super를 통해 재사용할 수 있습니다.

### 8.1.2 하위 클래스 초기화

* 코틀린에서는 특정 인스턴스를 생성할 때, 최상위 클래스를 탐색하며 상위 클래스에서 하위 클래스 순서로 초기화 코드가 실행됩니다.
* 주 생성자와 부 생성자가 존재할 때, 초기화 코드의 호출은 주 생성자를 통해 이뤄집니다.
* 부 생성자만 존재한다면 super 키워드를 통해 상위 클래스의 생성자를 호출할 수 있습니다.
* 상위 클래스가 여러 생성자를 제공하고 하위 클래스에서 상위 클래스의 생성자 중 둘 이상을 지원하고 싶을 때는 주 생성자를 선언하지 않고, 부 생성자만 정의하면 됩니다.
* this 누출이라는 문제가 있습니다. this 누출은 하위 클래스가 초기화 되기 전에 오버라이드한 메소드 호출로인해 예상하지 못한 결과가 반환되는 문제입니다.
  * this 누출 문제는 코틀린에서 널이 될 수 없는 타입의 변수 값이 널이 될 수 있는 드문 경우입니다.

### 8.1.3 타입 검사와 캐스팅

* 코틀린에서는 is 연산자를 통해서 해당 타입을 검사할 수 있습니다.
* is 연산자를 통해 특정 타입으로 추론할 수 있기 때문에 스마트 캐스팅이 가능합니다.
  * 컴파일러는 검사 시점과 사용 시점 사이에 변수가 변경되지 않는다고 확신할 때만 스마트 캐스트를 진행합니다.
* as 키워드를 통해 특정 타입으로 강제 변환을 할 수 있습니다.

### 8.1.4 공통 메소드

* 코틀린의 Any 클래스는 코틀린 클래스 계층 구조의 루트입니다.
* Any는 동등 연산(==, !=)과 hashCode, toString을 정의하고 있습니다.
* equals() 구현의 일반적인 요구 사항은 자바와 같습니다.
  * 널이 아닌 객체가 널과 같을 수 없다.
  * 동등성 연산은 반사적이어야 한다.
  * 동등성 연산은 대칭적이어야 한다.
  * 동등성 연산은 추이적이어야 한다.

## 8.2 추상 클래스와 인터페이스

### 8.2.1 추상 클래스와 추상 멤버

* 코틀린은 추상 클래스를 지원합니다.
* 추상 클래스는 직접 인스턴스화할 수 없고 다른 클래스의 상위 클래스 역할만 할 수 있는 클래스를 말합니다.
* 추상 클래스는 abstract 키워드를 통해 선언할 수 있습니다.
* 추상클래스는 추상 멤버를 정의할 수 있습니다.
  * 추상 멤버는 타입, 파라미터, 반환 타입 등 함수나 프로퍼티의 기본적인 모습을 정의하지만 세부 구현을 생략한 멤버입니다.
* 추상 클래스는 다음과 같은 제약이 있습니다.
  * 추상 프로퍼티를 초기화할 수 없고 명시적인 접근자나 by 절을 추가할 수 없다.
  * 추상 함수에는 본문이 없어야 한다.
  * 추상 프로퍼티와 함수 모두 명시적으로 반환 타입을 적어야 한다. 본문이나 초기화 코드가 없으므로 타입을 추론할 수 없기 때문이다.

### 8.2.2 인터페이스

* 인터페이스 멤버는 디폴트가 추상 멤버입니다.
* 자바의 디폴트 메소드와 비슷하게 코틀린에서도 인터페이스에 함수와 프로퍼티 구현을 추가할 수 있습니다.
* 인터페이스 내부에 상태를 정의할 수 없기 때문에 인터페이스 안에는 뒷받침하는 필드가 들어있는 프로퍼티를 정의할 수 없습니다.
* 인터페이스에는 생성자는 상태를 사용할 수 없는데 이는 다이아몬드 상속 문제를 방지하는 데 있습니다.
  * 다이아몬드 문제 : 다이아몬드 상속은 두 클래스가 동일한 클래스를 상속하고, 그 상위 클래스가 동일한 클래스를 상속할 때 발생하는 문제입니다.
  이러한 상황에서 상속받은 메소드나 속성이 어떤 상위 클래스로부터 왔는지 모호해집니다.


### 8.2.3 봉인된 클래스와 인터페이스

* 코틀린에서는 sealed class와 sealed interface를 통해 상속을 제한할 수 있습니다.
* 코틀린 1.1부터 봉인된 클래스가 다른 클래스를 상속할 수도 있습니다. 
또한 허용된 데이터 클래스의 상속 기능으로 인해, 데이터 클래스가 봉인된 클래스 계층에 속할 수도 있습니다.


### 8.2.4 위임

* 위임 패턴은 특정 기능을 다른 클래스의 객체에게 위임하고 처리하도록 하는 디자인패턴입니다.
* 코틀린에서는 by 를 통해 위임을 구현할 수 있습니다.

```Kotlin
interface Base {
    fun print()
}

class BaseImpl(val x: Int) : Base {
    override fun print() { print(x) }
}

class Derived(b: Base) : Base by b

fun main() {
    val b = BaseImpl(10)
    Derived(b).print() // 출력: 10
}
```