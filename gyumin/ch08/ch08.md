# 8장 클래스 계층 이해하기

## 8.1 상속

* 코틀린은 자바와 마찬가지로 단일 상속만 지원합니다.
* 상속을 지정하지 않으면 컴파일러는 자동으로 Any를 상속하는 것으로 가정합니다.

### 8.1.1 하위 클래스 선언

* 어떤 클래스를 상속하려면, 클래스를 정의하면서 주 생성자 뒤에 :을 넣으면 됩니다.

```Kotlin
open class Vehicle{
    var currentSpeed = 0
    
    fun start(){
        println("i'm moving")
    }
    
    fun stop(){
        ...
    }
}

open class FlyingVehicle: Vehicle(){
    ...
}
```

* 코틀린의 클래스는 기본적으로 상속 불가(final class)이기 때문에 `open` 키워드를 통해 해당 클래스가 상속할 수 있도록 지정할 수 있습니다.
* 인라인 클래스는 다른 클래스를 상속할 수 없으며, 다른 클래스의 상위 클래스 역할도 할 수 없습니다.
* 상속은 임의 다형성이라는 강력한 기능을 제공합니다.
    * 임의 다형성은 상위 클래스 멤버의 여러 다른 구현을 하위 클래스에서 제공하고, 런타임에 실제 인스턴스가 속한 클래스에 따라 구현을 선택해주는 기능입니다.

```Kotlin
open class Vehicle{
    open fun start(){
        ...
    }
    
    fun stop(){
        ...
    }
}

class Car: Vehicle(){
    overrride fun start(){
        ...
    }
}

class Boat: Vehicle(){
    overrride fun start(){
        ...
    }
}

fun startAndStop(vehicle: Vehicle){
    vehicle.start()
    vehicle.stop()
}

fun main(){
    startAndStop(Car())
    startAndStop(Boat())
}
```


* 코틀린은 자바와는 다르게 무조건 override를 명시해줘야합니다. 
이는 실수로 상위 메소드와 같은 이름을 가지는 메소드를 만들어 예상하지 못한 버그를 만들어내는것을 방지하기 위함입니다.
* 상위 클래스에서 정의된 메소드와 똑같은 이름과 시그니처를 가지는 확장 함수를 정의하더라도 상위 클래스의 메소드를 호출하게 됩니다.
* 코틀린은 메소드뿐만 아닌 프로퍼티도 오버라이드할 수 있습니다.
* 함수나 프로퍼티를 오버라이드할 때, 상위 클래스에서 정의한 값을 super를 통해 재사용할 수 있습니다.

### 8.1.2 하위 클래스 초기화

* 코틀린에서는 특정 인스턴스를 생성할 때, 최상위 클래스를 탐색하며 상위 클래스에서 하위 클래스 순서로 초기화 코드가 실행됩니다.
* 주 생성자와 부 생성자가 존재할 때, 초기화 코드의 호출은 주 생성자를 통해 이뤄집니다.
* 부 생성자만 존재한다면 super 키워드를 통해 상위 클래스의 생성자를 호출할 수 있습니다.
* 상위 클래스가 여러 생성자를 제공하고 하위 클래스에서 상위 클래스의 생성자 중 둘 이상을 지원하고 싶을 때는 주 생성자를 선언하지 않고, 부 생성자만 정의하면 됩니다.
* this 누출이라는 문제가 있습니다. this 누출은 하위 클래스가 초기화 되기 전에 오버라이드한 메소드 호출로인해 예상하지 못한 결과가 반환되는 문제입니다.
  * this 누출 문제는 코틀린에서 널이 될 수 없는 타입의 변수 값이 널이 될 수 있는 드문 경우입니다.

### 8.1.3 타입 검사와 캐스팅

* 코틀린에서는 is 연산자를 통해서 해당 타입을 검사할 수 있습니다.
* is 연산자를 통해 특정 타입으로 추론할 수 있기 때문에 스마트 캐스팅이 가능합니다.
  * 컴파일러는 검사 시점과 사용 시점 사이에 변수가 변경되지 않는다고 확신할 때만 스마트 캐스트를 진행합니다.
* as 키워드를 통해 특정 타입으로 강제 변환을 할 수 있습니다.

### 8.1.4 공통 메소드

* 코틀린의 Any 클래스는 코틀린 클래스 계층 구조의 루트입니다.
* Any는 동등 연산(==, !=)과 hashCode, toString을 정의하고 있습니다.
* equals() 구현의 일반적인 요구 사항은 자바와 같습니다.
  * 널이 아닌 객체가 널과 같을 수 없다.
  * 동등성 연산은 반사적이어야 한다.
  * 동등성 연산은 대칭적이어야 한다.
  * 동등성 연산은 추이적이어야 한다.