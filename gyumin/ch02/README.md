# 2장 코틀린 언어 기초

## 2.1 기본 문법

### 2.1.1 주석

* 코틀린은 자바와 마찬가리고 세 가지 주석을 지원합니다.

```Kotlin
// 한 줄짜리 주석
/* */ 여러줄 주석
/** */ KDoc 여러 줄 주석
```

* KDoc 주석은 자바독과 비슷한 리치 텍스트 문서를 생성하기 위해 사용합니다.

### 2.1.2 변수 정의하기

* 변수를 구성하는 요소는 다음과 같습니다.
    * val 키워드 : 값을 뜻하는 value에서 유래했습니다.
    * 변수 식별자 : 새 변수에 이름을 부여하고, 나중에 이를 가리킬 때 사용합니다.
    * 변수의 초깃값 : = 기호 뒤에 옵니다.

```Kotlin
val timeInSeconds = 15
```

* 코틀린에서는 타입 추론을 통해서 개발자가 직접 타입을 명시하지 않더라도 컴파일할 수 있습니다.
* 타입 추론 덕분에 코틀린은 강한 타입 지정 언어인 동시에 사용자가 불필요한 타입 정보를 코드에 추가해서 코드가 지저분해지는 일을 막을 수 있습니다.

### 2.1.3 식별자

* 식별자는 변수나 함수 등 프로그램에 정의된 대상에 붙은 이름입니다.
* 코틀린의 식별자는 두 가지로 구분됩니다.
    * 자바 식별자와 비슷하며 다음과 같은 규칙을 만족하는 임의의 문자열입니다.
        * 식별자는 오직 문자, 숫자, 및줄 문자만 포함한다. 숫자로 식별자를 시작할 수 없습니다.
        * 밑줄로만 이뤄질 수 있습니다. 하지만 이런 식별자는 모두 미리 예약된 식별자이므로 일반적인 식별자로 사용될 수 없습니다.
        * 하드 키워드를 식별자로 사용할 수 없습니다.
    * 작은 따옴표(`)로 감싼 식별자를 통해 빈 문자열을 제외한 아무 문자열을 식별자로 사용할 수 있습니다.

```Kotlin
fun `test test` = 1
```

### 2.1.4 가변 변수

* 불변 변수(val)을 사용하면 부수 효과를 일으키지 못하고, 함수형 스타일 코드를 장려할 수 있으며, 이로인해 코드에 대한 추론이 쉬워지기에 가능하면 불변 변수를 많이 사용해야 합니다.
* var를 통해 가변 변수를 사용할 수 있습니다.
* 가변 변수를 사용함에 있어 처음 변수에 값을 대입할 때, 추론된 타입은 변수가 불변이든 그렇지 않든 계속 유지됩니다.
* 코틀린은 복합 대입 연산이라는 대입과 이항 연산을 조합한 연산도 제공합니다.(ex. *=, /=, +=)

## 2.2 기본 타입

* 자바와 코틀린의 타입은 완벽하게 대응되지 않습니다.
* 자바에서의 원시타입(메소드의 스택 영역에 저장될 수 있다.)과 클래스를 기반으로 하는 참조 타입(동적으로 힙에 할당된 메모리를 포인팅)사이에 구분이 있습니다.
* 코틀린에서는 같은 타입도 문맥에 따라 원시 타입과 참조 타입을 가리키기 때문에 구분이 모호합니다.
* 코틀린에서는 자바에서의 Object와 비슷하게 Any가 존재합니다.

### 2.2.1 정수 타입

| 이름    | 크기(바이트) | 범위             | 대응하는 자바 타입 |
|-------|---------|----------------|------------|
| Byte  | 1       | -128...127     | Byte       |
| Short | 2       | -32768...32767 | Short      |
| Int   | 4       | -2^31...2^31-1 | Int        |
| Long  | 8       | -2^63...2^63-1 | Long       |

### 2.2.2 부동소수점 수

* 부동소수점을 표현할 때, 정수 부분을 생략하면 정수 부분을 0으로 취급하며 소수 부분은 생략할 수 없습니다.

### 2.2.3 산술 연산

* 코틀린 1.5부터 표준 라이브러리에 정수 floorDiv()와 mod() 메소드가 추가됐습니다.
  * floorDiv() : 한 수를 다른 수로 나눈 몫을 계산
  * mod() : 한 수를 다른 수로 나눈 나머지
* 각 이항 산술 연산마다 모든 가능한 수 타입 간의 연산을 지원하기 위한 변종이 함께 제공됩니다.
* 산술 연산의 결과는 인자 중 더 큰 의미를 지니는 타입이 됩니다.
    * Double > Float > Long > Int > Short > Byte
    * Long이 Float으로 변환되는 경우를 제외하고 대부분의 경우 타입 변환이 되면서 값의 범위가 넓어집니다. 

### 2.2.4 비트 연산

* Int와 Long은 비트 수준의 연산을 지원합니다.

| 연산   | 뜻             | 해당하는 자바 연산 |
|------|---------------|---|
| shl  | 왼쪽 시프트        | << |
| shr  | 오른쪽 시프트       | >> |
| ushr | 부호 없는 오른쪽 시프트 | >>> |
| and  | 비트 곱          | & |
| or   | 비트 합          | \||
|xor| 비트 배타합        |^|
|inv| 비트 반전         |~|

### 2.2.5 문자 타입 char

* Char 타입은 유니코드 한 글자를 표현하며 16비트입니다.
* 새줄 문자와 같은 특수 문자를 위해 코틀린은 이스케이프를 제공합니다.
  * \t : 탭
  * \b : 백스페이스
  * \n : 새줄
  * \r : 캐리지 리턴
  * \' : 작은 따옴표
  * \" : 큰따옴표
  * \\ : 역슬래시
  * \$ : 달려

### 2.2.6 수 변환

* 정수 타입 사이의 변환은 대상 타입이 더 큰 범위를 담는 타입인 경우 손실 없이 수행됩니다. 그렇지 않은 경우 MSB(most significant bit)를 잘라내고 나머지를 대상 타입의 값으로 변환합니다.
* 부동소수점 수 타입과 관련된 변환의 경우, 일반적으로 대상 타입과 문관하게 정밀도를 잃을 수 있습니다.

### 2.2.7 불 타입과 논리 연산

* 코틀린은 참이나 거짓 중 하나로 판명되는 불 타입과 논리 연산을 제공합니다.
* 불이 지원하는 연산은 다음과 같습니다.
  * ! : 논리 부정
  * or, and, xor : 즉시 계산 방식의 논리합, 논리곱, 논리배타합
  * ||, && : 지연 계산 방식의 논리합, 논리 곱

### 2.2.8 비교와 동등성

* 코틀린 타입은 두 인자가 모두 같은 타입일 때만 ==와 !=를 허용합니다.
* 모든 수 타입의 값은 서로 <,<=,>,>=를 사용해 비교할 수 있습니다. 이는 수 타입 사이의 산술 연산이 가능한 모든 경우를 다룰 수 있도록 오버로딩된 것과 마찬가지입니다.
* 기본적으로 NaN은 그 어떤 값과도 갖지 않습니다.
* NaN은 다음과 같은 특징을 가지고 있습니다.
  * NaN은 자기 자신과 같습니다.
  * NaN은 Double에서 가장 큰 값으로 취급됩니다.

## 2.3 문자열

* 코틀린의 문자열은 자바와 마찬가지로 한 번 String 객체를 생성하면 문자를 변경할 수 없고 조회만 가능합니다. 
* 문자열을 바꾸기 위해서는 기존 문자열을 바탕으로 새로운 문자열을 만들어야 합니다.

### 2.3.1 문자열 템플릿

* 코틀린은 자바의 문자열 방식에 문자열을 합성하는 더 강력한 방법을 지원합니다.

```Kotlin
val name = readLine()
println("hello, $name!\n today is ${Date()}")
```

* 코틀린에서는 ${}을 통해서 어떤 코틀린 식이든 문자열에 넣을 수 있습니다.
* ${}을 사용할 때, 변수 참조일 경우 중괄호를 생략할 수 있습니다. 이러한 기능을 문자열 템플릿이라고 합니다.
* 문자열 템플릿 안의 식은 toString() 메소드를 통해서 문자열로 변환됩니다.
* 큰따옴표 3개(""")를 통해서 로우 문자열을 사용할 수 있습니다.

### 2.3.2 기본 문자열 연산

* 모든 String 인스턴스는 문자열에 든 문자 수를 표현하는 length와 문자열의 마지막 문자 인덱스를 표현하는 lastIndex 프로퍼티를 제공합니다.
* 인덱스를 대괄호([]) 안에 넣는 연산자를 사용해 개별 문자에 접근할 수 있습니다. 이때 잘못된 인덱스를 넘기면 StringIndexOutOfBoundsException이 발생합니다.
* + 연산을 통해 두 문자열을 연결할 수 있습니다.
+ 문자열은 !=, ==을 통해 동등성을 비교할 수 있습니다.
+ 문자열은 사전식 순서로 정렬되기에 <,>,<=,>= 같은 연산자를 사용해 문자열을 비교할 수 있습니다.
+ 문자열은 수 타입이나 불로 변환하는 toByte(), toShort(), toLong(),toFloat(),toDouble(), toBoolean()을 제공합니다.

## 2.4 배열

### 2.4.1 배열 정의하기

* 배열 구조를 구현하는 가장 일반적인 코틀린 타입은 Array<T>입니다.
* 배열을 생성할 때, 배열의 크기를 미리 알 수 있다면 표준 함수 중 하나를 사용해 배열을 생성할 수 있습니다.

```Kotlin
val a = emptyArray<String>()
val b = arrayOf("hello","world")
val c - arrayOf(1,4,9)
```

* 각 함수는 제네릭하며, 이는 메소드를 호출할 때, 원소의 타입을 지정해야 한다는 뜻입니다. 하지만 코틀린의 타입 추론을 통해 타입을 선언하지 않아도 됩니다.
* Array<Int>를 통해 배열을 선언하는 방법은 모든 원소를 박싱하기 때문에 실용적이지 않은 방법입니다. 이를 해결하기위해 코틀린은 각 타입에 맞는 배열 타입을 제공해줍니다.

### 2.4.2 배열 사용하기

* 배열은 문자열과 동일하게 size(문자열의 length)와 lastIndex 프로퍼티를 제공해줍니다.
* 잘못된 인덱스를 통해 배열에 접근하면 IndexOutOfBoundsException 예외가 발생합니다.
* 코틀린의 배열은 자바와 마찬가지로 배열 타입의 변수 자체에는 실제 데이터에 대한 참조를 저장합니다.
* copyOf() 메소드를 통해 원본과 별도의 배열을 만들 수 있습니다.
* 배열의 타입은 생성시 고정이므로, 다른 타입의 배열로 재할당할 수 없습니다.
* 배열을 생성하고 길이를 바꿀 수 없지만, + 연산을 통해서 원소를 추가한 새로운 배열을 생성할 수 있습니다.
* 문자열과 달리 배열에서의 동등성 비교는 값이 아닌 참조를 비교합니다. 값을 비교하기 위해서는 contentEquals() 메소드를 사용하면 됩니다.

