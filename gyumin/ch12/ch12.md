# 12장 자바 상호 운용성


## 12.1 자바 코드를 코틀린에서 사용하기

* 코틀린은 JVM을 주 대상으로 설계됐기 때문에 상당히 쉽게 자바 코드를 코틀린에서 사용할 수 있다.
* 코틀린과 자바 상호 운용에 있어서 자바에 없는 코틀린 기능으로 인해 문제가 생길 수 있다.
    * 널 안정성

### 12.1.1 자바 메소드와 필드

* 코틀린에서 자바 코드를 사용할 때는 자바 코드의 메소드와 필드를 코틀린에서 사용할 수 있다.

### 12.1.2 Unit과 void

* 코틀린에는 반환값이 없음을 나타내는 void 키워드가 없습니다.

#### 연산자 관습

* Map.get() 같은 몇몇 자바 메소드는 코틀린의 연산자 관습을 만족한다.
* 이런 종류의 자바 메소드는 operator 키워드가 붙어있지 않지만, 코틀린에서는 이들을 마치 연산자 함수인 것처럼 연산자를 통해 사용할 수 있다.
* 중위 호출 문법은 자바 메소드에 적용할 수 없습니다.

### 12.1.3 합성 프로퍼티

* 자바에는 합성 프로퍼티가 없고, 게터와 세터를 사용하는 일이 많습니다. 이를 코틀린 컴파일러는 게터와 세터를 프로퍼티처럼 사용할 수 있도록 변환시켜줍니다.
  * 게터는 파라미터가 없는 메소드여야 하며, 메소드 이름은 get으로 시작해야 한다.
  * 세터는 파라미터가 하나만 있는 메소드여야 하며, 메소드 이름은 set으로 시작해야 한다.
* 자바에서 세터메소드만 제공하는 경우 코틀린에서는 프로퍼티로 노출되지 않습니다.


### 12.1.4 플랫폼 타입

* 자바가 널이 될 수 있는 타입과 그렇지 않은 타입을 구분하지 않기에 코틀린 컴파일러는 해당 프로퍼티가 널이 될 수 있는지 없는지 구분할 수 없습니다.
* 코틀린 컴파일러는 자바 코드가 노출하는 타입에 대한 널 안정성 검사를 완화시켜, 자바 타입을 명확한 널 가능성이 지정되지 않은 타입인 것처럼 취급한다.
* 코틀린에서는 자바 코드로부터 비롯된 객체는 플랫폼 타입이라는 특별한 타입에 속합니다.
* 플랫폼 타입을 코틀린 소스코드에서 명시할 수 없습니다.
  * 타입과 !가 붙어 있다면 해당 타입이 `타입?` 이거나 `타입` 일 수 있습니다.
* 플랫폼 타입을 널이 아닌 타입으로 강제로 변환하면 컴파일러가 단언문을 자동으로 생성해줍니다.
* 코틀린은 자바 컬렉션 타입을 표현할 때도 플랫폼 타입을 쓴다.
  * 코틀린과 달리 자바는 가변 컬렉션과 불변 컬렉션을 구분하지 않습니다.


### 12.1.5 널 가능성 애너테이션

* 자바 세계에서 널 안전성을 보장하는 일반적인 방법은 특별한 애너테이션을 사용하는 것입니다.
* 코틀린 컴파일러가 지원하는 널 가능성 애노테이션은 다음과 같습니다.
  * jetbrains 안에 있는 애노테이션
    * @Nullable
    * @NotNull
  * 안드로이드 프레임워크에 포함된 @Nullable, @NotNull 번종들
  * @Nonnull 등의 JSR-350 널 가능성 애너테이션


### 12.1.6 자바/코틀린 타입 매핑

* 자바와 코틀린에서는 비슷한 의미를 가지는 타입도 있습니다.
  * java(int, boolean) : kotlin(Int, Boolean)
  * java(List) : kotlin((Mutable)List)
* 코틀린 컴파일러는 JVM 플랫폼에서 실행되도록 컴파일하는 경우, 자바 코드에 선언된 내용을 코틀린 코드에서 사용하거나 그 반대의 경우에서 사용하는 경우 서로 상호 변환해줍니다.


| 자바 타입       | 코틀린 타입 |
|-------------|--------|
| byte,Byte   | Byte |
| short,Short | Short |
| int,Integer | Int |
| long,Long   | Long |
| char,Character | Char |
| float,Float | Float |
| double,Double | Double |


* JVM에서 기본 코틀린 타입의 값은 값이 사용되는 방식에 따라 원시 타입이거나 박싱 타입입니다.
* java.lang 패키지에 들어있는 원시 타입이 아닌 내장 클래스 중 일부도 kotlin 패키지에 있는 상응하는 코틀린 클래스로 매핑된다.
  * Object
  * Cloneable
  * Comparable
  * Enum
  * Annotation
  * CharSequence
  * String
  * Number
  * Throwable
* 코틀린으로 매핑된 자바 클래스의 정적 멤버를 코틀린 쪽 동반 객체에서 직접 접근할 수 없습니다.
  * 정적 멤버를 사용하려면 전체 이름을 언급해야 합니다.
* 코틀린 표준 컬렉션 타입은 java.util 패키지에 있는 상응하는 컬렉션 타입으로 매핑됩니다.
  * Iterable, Iterator, ListIterator
  * Collection
  * Set
  * List
  * Map/Map.Entry
* 자바의 extends 와일드카드는 코틀린 공변 프로젝션으로 변환된다.
* 자바의 super 와일드카드는 코틀린 반공변 프로젝션으로 변환된다.
* 자바의 로우 타입은 코틀린 스타 프로젝션으로 바뀐다.
* 원시 타입으로 이뤄진 자바 배열은 박싱/언박싱을 피아기 위해 상응하는 특화된 코틀린 배열 클래스(IntArray)로 매핑된다.
* 특화 배열 외 Array<(out)T>라는 특별한 플랫폼 타입의 배열 인스턴스로 변환된다.
  * 이런 변환으로 상위 타입의 배열을 받으리라 예상하는 자바 메소드에게 하위 타입의 배열을 넘길 수 있습니다.
  * 코틀린 배열은 무공변으로 코틀린 메소드에 대해서는 이런 기법을 사용할 수 없습니다.


### 12.1.7 단일 추상 메소드 인터페이스

* 추상 메소드가 아나뿐인 자바 인터페이스를 코틀린에서는 함수 타입처럼 작동합니다.
* 컴파일러가 문맥을 충분히 파악할 수 없는 경우 변환하지 못할 수 있습니다. 이때는 대상 타입을 지정함으로써 해결할 수 있습니다. 이를 SAM 생성자라고 부릅니다.


```Kotlin
fun main(){
    val executor = ScheduledThreadPoolExecutor(5)
    val future = executor.submit(Callable{1+2})
    
    println(future.get())
    executor.shutdown()
}
```

* SAM 변환은 인터페이스에 대해서만 적용되고, 메소드가 하나뿐인 클래스에 적용될 수 없습니다.
* 코틀린 인터페이스에 대해서도 SAM 변환을 쓸 수 없습니다.
* 자바의 SAM 변환을 코틀린에서 정의한 인터페이스로도 사용하고 싶을 때, 코틀린에서 함수형 인터페이스를 선언함으로써 인터페이스의 인스턴스 대신 람다를 쓸 수 있습니다.

```Kotlin
fun interface SomeCallback{
    fun execute(arg: Any): Unit
}

fun callWithString(arg: String, callback: SomeCallback) = callback.execute(arg)

fun main(){
    callWithString("world!"){ println("Hello, $it") }
} 
```


### 12.1.8 자바를 코틀린으로 변환하는 변환기 사용하기

* 자바 코드를 코틀린으로 변환하는 변환기는 IntelliJ IDEA에 내장되어 있습니다.



## 12.2 코틀린 코드를 자바에서 사용하기

### 12.2.1 프로퍼티 접근

* 자바에는 프로퍼티 개념이 없지만 코틀린 컴파일러가 프로퍼티를 자바로 변환하는 과정에서 접근자 메소드를 만들어 줍니다.
  * 게터는 get으로 시작하고, 세터는 set으로 시작합니다.
  * 프로퍼티 이름이 is로 시작하는 경우 게터 메소드의 이름은 get을 붙이지 않습니다. 세터는 is를 제거하고 set을 붙입니다.
* 코틀린 프로퍼티에 뒷받침하는 필드가 필요한 경우, 컴파일러가 접근자 메소드와 함께 필드도 만들어 줍니다.
  * 필드를 기본적으로 private이지만 @JvmField 애노테이션을 붙이면 public으로 만들 수 있습니다.
  * @JvmField는 추상 프로퍼티나 열린 프로퍼티에 적용할 수도 없습니다.
  * 일므 붙은 객체의 프로퍼티에 대해 @JvmField를 적용하면 인스턴스 필드가 아닌 정적 필드를 만들어 냅니다.
* 뒷받침하는 필드를 lateinit을 통해서 노출할 수 있습니다.
* 객체에서 lateinit은 @JvmField가 붙은 필드와 비슷한 정적 필드를 생성합니다. 하지만 lateinit 프로퍼티의 접근자는 인스턴스 메소드로 남습니다.
* lateinit 프로퍼티에 @JvmField를 붙일 수 없습니다.

### 12.2.2 파일 퍼사드와 최상위 선언

* 코틀린에서는 패키지 바로 아래두는 최상위 선언을 자주 사용합니다. 이는 자바에서의 선언과 다르기에 코틀린 컴파일러는 최상위 함수와 프로퍼티를 자동으로 생성된 파일  퍼사드라는 클래스에 넣습니다.
* 퍼사드 클래스 이름은 소스코드 뒤에 Kt를 덧 붙인 이름이 됩니다.
* 퍼사드 클래스에 생성된 메소드가 정적 메소드이므로 자바 코드에서 최상위 메소드에 접근할 때 퍼사드 클래스를 인스턴스화 할 필요가 없습니다.
* @JvmName을 통해서 퍼사드 클래스 이름을 지정할 수 있습니다.
* @JvmMultifileClass를 통해서 최상위 선언을 한 클래스에 모을 수 있습니다.


### 12.2.3 객체와 정적 멤버

* JVM에서 코틀린 객체 선언은 정적인 INSTANCE 필드가 있는 일반적인 클래스로 컴파일됩니다. 
* 자바에서 코틀린 객체에 접근하기 위해서는 INSTANCE 필드를 통해서 접근해야 합니다.
* @JvmField를 통해서 INSTANCE 필드가 아닌 프로퍼티를 통해 바로 접근할 수 있습니다.

### 12.2.4 노출된 선언 이름 변경하기

* @JvmName은 파일뿐만아닌 함수나 프로퍼티에도 적용할 수 있습니다.
  * 프로퍼티 접근자와 이 접근자의 코틀린 컴파일 결과의 이름과 같은 함수를 정의하면 충돌이 발생하며 이때 @JvmName을 통해 접근자 또는 함수의 이름을 변경하여 충돌을 해결할 수 있습니다.

### 12.2.5 오버로딩한 메소드 생성하기

* 코틀린 함수에 디폴트 값이 지정된 경우, 함수 인자 중 일부를 생략할 수 있기 때문에 함수를 호출할 때 인자의 수가 달라질 수 있습니다.
* 자바에서는 디폴트 개념이 없기 때문에 @JvmOverloads를 통해서 오버로딩한 메소드를 생성할 수 있습니다.
  * 오버로딩된 첫 번쨰 함수는 마지막 파라미터를 제외한 나머지 인자를 받는 함수이며, 이 함수는 원래 함수의 마지막 파라미터를 디폴트 값으로 지정해준다.
  * 오버로딩된 두 번째 함수는 마지막 두 파라미터를 제외한 나머지 인자를 받는 함수이며, 이 함수는 원래 함수의 마지막 두 파라미터를 디폴트 값으로 지정해준다.
  * 오버로딩된 마지막 함수는 파리미터를 하나만 받고, 나머지 파라미터를 디폴트 값으로 적용해준다.

### 12.2.6 예외 선언하기

* 코틀린은 검사 예외와 비검사 예외를 구분하지 않지만 자바에서는 구분하기 때문에 코틀린 함수에서 예외를 선언할 때는 @Throws를 사용함으로써 자바로 컴파일할 때 throws 절에 예외를 명시할 수 있습니다.
* 코틀린 컴파일러는 기반 클래스의 멤버와 이 멤버를 오버라이딩한 자식 클래스의 멤버에 붙은 @Throws 예외 선언의 일관성을 검증하지 않습니다.

### 12.2.7 인라인 함수

* 자바에서는 인라인 함수가 없기 때문에 코틀린에서 inline 변경자가 붙은 함수는 일반 메소드로 자바 쪽에 호출됩니다.
* 자바에서 이런 메소드를 호출하더라도 인라인화되지 않습니다.
* 인라인을 사용하지 않고 구체화를 구현할 방법이 없기 때문에 해당 함수는 자바에서 사용할 수 없습니다.

### 12.2.8 타입 별명

* 코틀린 타입 별명은 자바에서 사용할 수 없습니다. 자바 관점에서 해당 타입들은 모두 원래 타입을 가리키는 것으로 보이기 때문입니다.