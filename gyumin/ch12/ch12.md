# 12장 자바 상호 운용성


## 12.1 자바 코드를 코틀린에서 사용하기

* 코틀린은 JVM을 주 대상으로 설계됐기 때문에 상당히 쉽게 자바 코드를 코틀린에서 사용할 수 있다.
* 코틀린과 자바 상호 운용에 있어서 자바에 없는 코틀린 기능으로 인해 문제가 생길 수 있다.
    * 널 안정성

### 12.1.1 자바 메소드와 필드

* 코틀린에서 자바 코드를 사용할 때는 자바 코드의 메소드와 필드를 코틀린에서 사용할 수 있다.

### 12.1.2 Unit과 void

* 코틀린에는 반환값이 없음을 나타내는 void 키워드가 없습니다.

#### 연산자 관습

* Map.get() 같은 몇몇 자바 메소드는 코틀린의 연산자 관습을 만족한다.
* 이런 종류의 자바 메소드는 operator 키워드가 붙어있지 않지만, 코틀린에서는 이들을 마치 연산자 함수인 것처럼 연산자를 통해 사용할 수 있다.
* 중위 호출 문법은 자바 메소드에 적용할 수 없습니다.

### 12.1.3 합성 프로퍼티

* 자바에는 합성 프로퍼티가 없고, 게터와 세터를 사용하는 일이 많습니다. 이를 코틀린 컴파일러는 게터와 세터를 프로퍼티처럼 사용할 수 있도록 변환시켜줍니다.
  * 게터는 파라미터가 없는 메소드여야 하며, 메소드 이름은 get으로 시작해야 한다.
  * 세터는 파라미터가 하나만 있는 메소드여야 하며, 메소드 이름은 set으로 시작해야 한다.
* 자바에서 세터메소드만 제공하는 경우 코틀린에서는 프로퍼티로 노출되지 않습니다.


### 12.1.4 플랫폼 타입

* 자바가 널이 될 수 있는 타입과 그렇지 않은 타입을 구분하지 않기에 코틀린 컴파일러는 해당 프로퍼티가 널이 될 수 있는지 없는지 구분할 수 없습니다.
* 코틀린 컴파일러는 자바 코드가 노출하는 타입에 대한 널 안정성 검사를 완화시켜, 자바 타입을 명확한 널 가능성이 지정되지 않은 타입인 것처럼 취급한다.
* 코틀린에서는 자바 코드로부터 비롯된 객체는 플랫폼 타입이라는 특별한 타입에 속합니다.
* 플랫폼 타입을 코틀린 소스코드에서 명시할 수 없습니다.
  * 타입과 !가 붙어 있다면 해당 타입이 `타입?` 이거나 `타입` 일 수 있습니다.
* 플랫폼 타입을 널이 아닌 타입으로 강제로 변환하면 컴파일러가 단언문을 자동으로 생성해줍니다.
* 코틀린은 자바 컬렉션 타입을 표현할 때도 플랫폼 타입을 쓴다.
  * 코틀린과 달리 자바는 가변 컬렉션과 불변 컬렉션을 구분하지 않습니다.


### 12.1.5 널 가능성 애너테이션

* 자바 세계에서 널 안전성을 보장하는 일반적인 방법은 특별한 애너테이션을 사용하는 것입니다.
* 코틀린 컴파일러가 지원하는 널 가능성 애노테이션은 다음과 같습니다.
  * jetbrains 안에 있는 애노테이션
    * @Nullable
    * @NotNull
  * 안드로이드 프레임워크에 포함된 @Nullable, @NotNull 번종들
  * @Nonnull 등의 JSR-350 널 가능성 애너테이션


### 12.1.6 자바/코틀린 타입 매핑

* 자바와 코틀린에서는 비슷한 의미를 가지는 타입도 있습니다.
  * java(int, boolean) : kotlin(Int, Boolean)
  * java(List) : kotlin((Mutable)List)
* 코틀린 컴파일러는 JVM 플랫폼에서 실행되도록 컴파일하는 경우, 자바 코드에 선언된 내용을 코틀린 코드에서 사용하거나 그 반대의 경우에서 사용하는 경우 서로 상호 변환해줍니다.


| 자바 타입       | 코틀린 타입 |
|-------------|--------|
| byte,Byte   | Byte |
| short,Short | Short |
| int,Integer | Int |
| long,Long   | Long |
| char,Character | Char |
| float,Float | Float |
| double,Double | Double |


* JVM에서 기본 코틀린 타입의 값은 값이 사용되는 방식에 따라 원시 타입이거나 박싱 타입입니다.
* java.lang 패키지에 들어있는 원시 타입이 아닌 내장 클래스 중 일부도 kotlin 패키지에 있는 상응하는 코틀린 클래스로 매핑된다.
  * Object
  * Cloneable
  * Comparable
  * Enum
  * Annotation
  * CharSequence
  * String
  * Number
  * Throwable
* 코틀린으로 매핑된 자바 클래스의 정적 멤버를 코틀린 쪽 동반 객체에서 직접 접근할 수 없습니다.
  * 정적 멤버를 사용하려면 전체 이름을 언급해야 합니다.
* 코틀린 표준 컬렉션 타입은 java.util 패키지에 있는 상응하는 컬렉션 타입으로 매핑됩니다.
  * Iterable, Iterator, ListIterator
  * Collection
  * Set
  * List
  * Map/Map.Entry
* 자바의 extends 와일드카드는 코틀린 공변 프로젝션으로 변환된다.
* 자바의 super 와일드카드는 코틀린 반공변 프로젝션으로 변환된다.
* 자바의 로우 타입은 코틀린 스타 프로젝션으로 바뀐다.
* 원시 타입으로 이뤄진 자바 배열은 박싱/언박싱을 피아기 위해 상응하는 특화된 코틀린 배열 클래스(IntArray)로 매핑된다.
* 특화 배열 외 Array<(out)T>라는 특별한 플랫폼 타입의 배열 인스턴스로 변환된다.
  * 이런 변환으로 상위 타입의 배열을 받으리라 예상하는 자바 메소드에게 하위 타입의 배열을 넘길 수 있습니다.
  * 코틀린 배열은 무공변으로 코틀린 메소드에 대해서는 이런 기법을 사용할 수 없습니다.


### 12.1.7 단일 추상 메소드 인터페이스

* 추상 메소드가 아나뿐인 자바 인터페이스를 코틀린에서는 함수 타입처럼 작동합니다.
* 컴파일러가 문맥을 충분히 파악할 수 없는 경우 변환하지 못할 수 있습니다. 이때는 대상 타입을 지정함으로써 해결할 수 있습니다. 이를 SAM 생성자라고 부릅니다.


```Kotlin
fun main(){
    val executor = ScheduledThreadPoolExecutor(5)
    val future = executor.submit(Callable{1+2})
    
    println(future.get())
    executor.shutdown()
}
```

* SAM 변환은 인터페이스에 대해서만 적용되고, 메소드가 하나뿐인 클래스에 적용될 수 없습니다.
* 코틀린 인터페이스에 대해서도 SAM 변환을 쓸 수 없습니다.
* 자바의 SAM 변환을 코틀린에서 정의한 인터페이스로도 사용하고 싶을 때, 코틀린에서 함수형 인터페이스를 선언함으로써 인터페이스의 인스턴스 대신 람다를 쓸 수 있습니다.

```Kotlin
fun interface SomeCallback{
    fun execute(arg: Any): Unit
}

fun callWithString(arg: String, callback: SomeCallback) = callback.execute(arg)

fun main(){
    callWithString("world!"){ println("Hello, $it") }
} 
```


### 12.1.8 자바를 코틀린으로 변환하는 변환기 사용하기

* 자바 코드를 코틀린으로 변환하는 변환기는 IntelliJ IDEA에 내장되어 있습니다.